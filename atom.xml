<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[JSBear]]></title>
  
  <link href="/jsbear/atom.xml" rel="self"/>
  <link href="http://jsbear.baidu.com/"/>
  <updated>2015-01-25T13:10:10.731Z</updated>
  <id>http://jsbear.baidu.com/</id>
  
  <author>
    <name><![CDATA[JSBear Team]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[详解this]]></title>
    <link href="http://jsbear.baidu.com/2015/01/18/all-this/"/>
    <id>http://jsbear.baidu.com/2015/01/18/all-this/</id>
    <published>2015-01-18T20:47:24.000Z</published>
    <updated>2015-01-25T13:09:40.586Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>原文：<a href="http://bjorn.tipling.com/all-this" target="_blank" rel="external">all this</a><br>审阅校对：<a href="https://github.com/leeyeh" target="_blank" rel="external">leeyeh</a></p>
</blockquote>
<p>习惯了传统语言的你或许觉得JavaScript中的<code>this</code>跟Java这些面向对象语言相似，保存了实体属性的一些值。其实不然。将它视作<a href="http://harrypotter.wikia.com/wiki/Boggart" target="_blank" rel="external">幻影魔神</a>比较恰当，手提一个装满未知符文的<a href="http://harrypotter.wikia.com/wiki/Undetectable_Extension_Charm" target="_blank" rel="external">灵龛</a>。</p>
<p>以下内容我希望大家都来了解。全是掏箱底的干货，其中大部分占用了我很多时间才掌握。</p>
<a id="more"></a>

<h2 id="全局this">全局<code>this</code></h2>
<p>浏览器宿主的全局环境中，<code>this</code>指的是<code>window</code>对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/hL9emz4m/" target="_blank" rel="external">示例</a></p>
<p>浏览器中在全局环境下，使用<code>var</code>声明变量其实是赋值到了<code>this</code>或<code>window</code>里面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/1/" target="_blank" rel="external">示例</a></p>
<p>任何情况下，创建变量时没有使用<code>var</code>或者<code>let</code>（ECMAScript 6），也是在向全局<code>this</code>中添加或改变属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span><span class="params">()</span> </span>{</div><div class="line">      foo = <span class="string">"foo"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line">    testThis();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "foo"</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/3/" target="_blank" rel="external">示例</a></p>
<p>Node命令行（REPL）中，<code>this</code>是全局命名空间。可以通过<code>global</code>来访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; this</div><div class="line">{ ArrayBuffer: [Function: ArrayBuffer],</div><div class="line">  Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: <span class="number">1</span> },</div><div class="line">  Uint8Array: { [Function: Uint8Array] BYTES_PER_ELEMENT: <span class="number">1</span> },</div><div class="line">  ...</div><div class="line">&gt; global === this</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>

<p>在Node环境里执行的JS脚本中，<code>this</code>其实是个空对象，有别于<code>global</code>。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global);</div></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">{}</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure>

<p>当尝试在Node中执行JS脚本时，脚本中全局作用域中的<code>var</code>并不会将变量添加到全局<code>this</code>，这与在浏览器中是不一样的。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">"bar"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">undefined</div></pre></td></tr></table></figure>

<p>…但在命令行里进行求值却会添加到<code>this</code>身上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; var foo = <span class="string">"bar"</span>;</div><div class="line">&gt; this.foo</div><div class="line">bar</div><div class="line">&gt; global.foo</div><div class="line">bar</div></pre></td></tr></table></figure>

<p>在Node里执行的脚本中，创建变量时没带<code>var</code>或<code>let</code>关键字，会修改全局的<code>global</code>但不是<code>this</code>（译注：上面已经提到<code>this</code>和<code>global</code>不是同一个对象，所以这里就不奇怪了）。</p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo = <span class="string">"bar"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line"><span class="built_in">console</span>.log(global.foo);</div></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">undefined</div><div class="line">bar</div></pre></td></tr></table></figure>

<p>但在Node命令行里，就会赋值给两者了。</p>
<blockquote>
<p>译注：简单来说，Node脚本中<code>global</code>和<code>this</code>是区别对待的，而Node命令行中，两者可等效为同一对象。</p>
</blockquote>
<h2 id="函数或方法里的this">函数或方法里的<code>this</code></h2>
<p>除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数被正常调用（不带<code>new</code>）时，里面的<code>this</code>指向的是全局作用域。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span><span class="params">()</span> </span>{</div><div class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line">    testThis();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "foo"</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/4/" target="_blank" rel="external">示例</a></p>
<figure class="highlight js"><figcaption><span>test.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span> <span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(global.foo);</div><div class="line">testThis();</div><div class="line"><span class="built_in">console</span>.log(global.foo);</div></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node test.js</div><div class="line">bar</div><div class="line">foo</div></pre></td></tr></table></figure>

<p>还有个例外，就是使用了<code>&quot;use strict&quot;;</code>。此时<code>this</code>是<code>undefined</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span><span class="params">()</span> </span>{</div><div class="line"><span class="pi">      "use strict"</span>;</div><div class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line">    testThis();  <span class="comment">//Uncaught TypeError: Cannot set property 'foo' of undefined </span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/51/" target="_blank" rel="external">示例</a></p>
<p>当用调用函数时使用了<code>new</code>关键字，此刻<code>this</code>指代一个新的上下文，不再指向全局<code>this</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testThis</span><span class="params">()</span> </span>{</div><div class="line">      <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line">    <span class="keyword">new</span> testThis();</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo); <span class="comment">//logs "bar"</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> testThis().foo); <span class="comment">//logs "foo"</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/6/" target="_blank" rel="external">示例</a></p>
<p>我习惯将这个新的上下文称作实例。</p>
<h2 id="原型中的this">原型中的<code>this</code></h2>
<p>函数创建后其实以一个函数对象的形式存在着。既然是对象，则其自动获得了一个叫做<code>prototype</code>（原型）的属性，你可以自由地对这个属性进行属性添加或修改。当配合<code>new</code>关键字来调用一个函数创建实例后，此刻便能直接访问到原型身上的值。当然，是通过<code>this</code>来进行的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing(); <span class="comment">//logs "bar"</span></div><div class="line"><span class="built_in">console</span>.log(thing.foo);  <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/8/" target="_blank" rel="external">示例</a></p>
<p>当通过<code>new</code>的方式创建了多个实例后，他们会共用一个原型。比如，每个实例的<code>this.foo</code>都返回相同的值，除非你在某个实例中重写了<code>this.foo</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line">Thing.prototype.setFoo = <span class="function"><span class="keyword">function</span> <span class="params">(newFoo)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = newFoo;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</div><div class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</div><div class="line"></div><div class="line">thing1.logFoo(); <span class="comment">//logs "bar"</span></div><div class="line">thing2.logFoo(); <span class="comment">//logs "bar"</span></div><div class="line"></div><div class="line">thing1.setFoo(<span class="string">"foo"</span>);</div><div class="line">thing1.logFoo(); <span class="comment">//logs "foo";</span></div><div class="line">thing2.logFoo(); <span class="comment">//logs "bar";</span></div><div class="line"></div><div class="line">thing2.foo = <span class="string">"foobar"</span>;</div><div class="line">thing1.logFoo(); <span class="comment">//logs "foo";</span></div><div class="line">thing2.logFoo(); <span class="comment">//logs "foobar";</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/9/" target="_blank" rel="external">示例</a></p>
<p>在实例中，<code>this</code>是个特殊的对象，而<code>this</code>自身其实只是个关键字。你可以把<code>this</code>想象成在实例中访问挂载在原型上的值的一种途径，同时对<code>this</code>里面属性的改变又会隐藏原型上原来的值。如果需要访问挂载在原型上的值，你可以删除挂载在实例上的值…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line">Thing.prototype.setFoo = <span class="function"><span class="keyword">function</span> <span class="params">(newFoo)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = newFoo;</div><div class="line">}</div><div class="line">Thing.prototype.deleteFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.foo;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.setFoo(<span class="string">"foo"</span>);</div><div class="line">thing.logFoo(); <span class="comment">//logs "foo";</span></div><div class="line">thing.deleteFoo();</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar";</span></div><div class="line">thing.foo = <span class="string">"foobar"</span>;</div><div class="line">thing.logFoo(); <span class="comment">//logs "foobar";</span></div><div class="line"><span class="keyword">delete</span> thing.foo;</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar";</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/11/" target="_blank" rel="external">示例</a></p>
<p>…或者直接引用函数的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo, Thing.prototype.foo);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.foo = <span class="string">"foo"</span>;</div><div class="line">thing.logFoo(); <span class="comment">//logs "foo bar";</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/12/" target="_blank" rel="external">示例</a></p>
<p>同一函数创建的所有实例均共享一个原型。如果你给原型赋值了一个数组，那么所有实例都能获取到这个数组。除非你在某个实例中对其进行了重写，实事上是进行了覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.things = [];</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</div><div class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</div><div class="line">thing1.things.push(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(thing2.things); <span class="comment">//logs ["foo"]</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/13/" target="_blank" rel="external">示例</a></p>
<p>通常上面的做法是不正确的（译注：改变<code>thing1</code>的同时也影响了<code>thing2</code>）。如果你想每个实例互不影响，那么请在函数里创建这些值，而不是在原型上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.things = [];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing1 = <span class="keyword">new</span> Thing();</div><div class="line"><span class="keyword">var</span> thing2 = <span class="keyword">new</span> Thing();</div><div class="line">thing1.things.push(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(thing1.things); <span class="comment">//logs ["foo"]</span></div><div class="line"><span class="built_in">console</span>.log(thing2.things); <span class="comment">//logs []</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/14/" target="_blank" rel="external">示例</a></p>
<p>多个原型可以形成原型链，这样<code>this</code>便会在原型链上逐步往上找直到找到你想引用的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</div><div class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/15/" target="_blank" rel="external">示例</a></p>
<p>很多人便是利用这个特性在JS中模拟经典的对象继承。</p>
<p>注意，在用于开成原型链的函数中对<code>this</code>进行修改会覆盖之前同名的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">}</div><div class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing3</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing3.prototype = <span class="keyword">new</span> Thing2();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing3();</div><div class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">//logs "foo"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/16/" target="_blank" rel="external">示例</a></p>
<p>我习惯将赋值到原型上的函数称作方法。上面某些地方便使用了方法这样的字眼，比如<code>logFoo</code>方法。这些方法中的<code>this</code>同样具有在原型链上查找引用的魔力。通常将最初用来创建实例的函数称作构造函数。</p>
<p>原型链方法中的<code>this</code>是从实例中的<code>this</code>开始住上查找整个原型链的。也就是说，如果原型链中某个地方直接对<code>this</code>进行赋值覆盖了某个变量，那么，不管是在哪一级原型链的方法中，我们拿到的都会是覆盖后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing1.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">}</div><div class="line">Thing2.prototype = <span class="keyword">new</span> Thing1();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</div><div class="line">thing.logFoo(); <span class="comment">//logs "foo";</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/17/" target="_blank" rel="external">示例</a></p>
<p>在JavaScript中，函数可以嵌套函数，也就是你可以在函数里面继续定义函数。但内层函数是通过闭包获取外层函数里定义的变量值的，而不是直接继承<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> info = <span class="string">"attempting to log this.foo:"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(info, <span class="keyword">this</span>.foo);</div><div class="line">    }</div><div class="line">    doIt();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo();  <span class="comment">//logs "attempting to log this.foo: undefined"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/21/" target="_blank" rel="external">示例</a></p>
<p>上面示例中，<code>doIt</code> 函数中的<code>this</code>指代全局作用域，如果使用了<code>&quot;use strict&quot;;</code>声明的话是<code>undefined</code>。对于很多新手来说，理解这点是非常头疼的。</p>
<p>还有更奇葩的。把实例的方法作为参数传递时，实例是不会跟着过去的。也就是说，此时方法中的<code>this</code>在调用时指向的是全局<code>this</code>，如果使用了<code>&quot;use strict&quot;;</code>声明的话是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{  </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);   </div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">(method)</span> </span>{</div><div class="line">    method();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></div><div class="line">doIt(thing.logFoo); <span class="comment">//logs undefined</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/22/" target="_blank" rel="external">示例</a></p>
<p>所以很多人习惯将<code>this</code>暂存起来，用个叫<code>self</code>或者其他什么的变量来保存，以将外层与内层的<code>this</code>区分开来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">var</span> info = <span class="string">"attempting to log this.foo:"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(info, self.foo);</div><div class="line">    }</div><div class="line">    doIt();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo();  <span class="comment">//logs "attempting to log this.foo: bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/23/" target="_blank" rel="external">示例</a></p>
<p>…但上面的方式不是万能的，在将方法做为参数传递时，就不起作用了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ </div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(self.foo);</div><div class="line">    }</div><div class="line">    doIt();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doItIndirectly</span><span class="params">(method)</span> </span>{</div><div class="line">    method();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></div><div class="line">doItIndirectly(thing.logFoo); <span class="comment">//logs undefined</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/24/" target="_blank" rel="external">示例</a></p>
<p>解决方法就是传递的时候使用<code>bind</code>方法显示指明上下文，<code>bind</code>方法是所有函数或方法都具有的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ </div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">(method)</span> </span>{</div><div class="line">    method();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">doIt(thing.logFoo.bind(thing)); <span class="comment">//logs bar</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/25/" target="_blank" rel="external">示例</a></p>
<p>同时也可以使用<code>apply</code>或<code>call</code>来调用该方法或函数，让它在一个新的上下文中执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doIt</span><span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">    }</div><div class="line">    doIt.apply(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doItIndirectly</span><span class="params">(method)</span> </span>{</div><div class="line">    method();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">doItIndirectly(thing.logFoo.bind(thing)); <span class="comment">//logs bar</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/26/" target="_blank" rel="external">示例</a></p>
<p>使用<code>bind</code>可以任意改变函数或方法的执行上下文，即使它没有被绑定到一个实例的原型上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logFoo</span><span class="params">(aStr)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(aStr, <span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">logFoo.bind(thing)(<span class="string">"using bind"</span>); <span class="comment">//logs "using bind bar"</span></div><div class="line">logFoo.apply(thing, [<span class="string">"using apply"</span>]); <span class="comment">//logs "using apply bar"</span></div><div class="line">logFoo.call(thing, <span class="string">"using call"</span>); <span class="comment">//logs "using call bar"</span></div><div class="line">logFoo(<span class="string">"using nothing"</span>); <span class="comment">//logs "using nothing undefined"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/27/" target="_blank" rel="external">示例</a></p>
<p>避免在构造函数中返回任何东西，因为返回的东西可能覆盖本来该返回的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> {};</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"></div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo(); <span class="comment">//Uncaught TypeError: undefined is not a function</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/28/" target="_blank" rel="external">示例</a></p>
<p>但，如果你在构造函数里返回的是个原始值比如字符串或者数字什么的，上面的错误就不会发生了，返回语句将被忽略。所以最好别在一个将要通过<code>new</code>来调用的构造函数中返回任何东西，即使你是清醒的。如果你想实现工厂模式，那么请用一个函数来创建实例，并且不通过<code>new</code>来调用。当然这只是个人建议。</p>
<p>诚然，你也可以使用<code>Object.create</code>从而避免使用<code>new</code>。这样也能创建一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"></div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing =  <span class="built_in">Object</span>.create(Thing.prototype);</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/29/" target="_blank" rel="external">示例</a></p>
<p>这种方式不会调用该构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"></div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> thing =  <span class="built_in">Object</span>.create(Thing.prototype);</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/30/" target="_blank" rel="external">示例</a></p>
<p>正因为<code>Object.create</code>没有调用构造函数，这在当你想实现继承时是非常有用的，随后你可能想要重写构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing1</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.foo = <span class="string">"foo"</span>;</div><div class="line">}</div><div class="line">Thing1.prototype.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing2</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.logFoo(); <span class="comment">//logs "bar"</span></div><div class="line">    Thing1.apply(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.logFoo(); <span class="comment">//logs "foo"</span></div><div class="line">}</div><div class="line">Thing2.prototype = <span class="built_in">Object</span>.create(Thing1.prototype);</div><div class="line">Thing2.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing2();</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/32/" target="_blank" rel="external">示例</a></p>
<h2 id="对象中的this">对象中的<code>this</code></h2>
<p>可以在对象的任何方法中使用<code>this</code>来访问该对象的属性。这与用<code>new</code>得到的实例是不一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = {</div><div class="line">    foo: <span class="string">"bar"</span>,</div><div class="line">    logFoo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">obj.logFoo(); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/33/" target="_blank" rel="external">示例</a></p>
<p>注意这里并没有使用<code>new</code>，也没有用<code>Object.create</code>，更没有函数的调用来创建对象。也可以将函数绑定到对象，就好像这个对象是一个实例一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = {</div><div class="line">    foo: <span class="string">"bar"</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logFoo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">}</div><div class="line"></div><div class="line">logFoo.apply(obj); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/34/" target="_blank" rel="external">示例</a></p>
<p>此时使用<code>this</code>没有向上查找原型链的复杂工序。通过<code>this</code>所拿到的只是该对象身上的属性而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = {</div><div class="line">    foo: <span class="string">"bar"</span>,</div><div class="line">    deeper: {</div><div class="line">        logFoo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">obj.deeper.logFoo(); <span class="comment">//logs undefined</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/35/" target="_blank" rel="external">示例</a></p>
<p>也可以不通过<code>this</code>，直接访问对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = {</div><div class="line">    foo: <span class="string">"bar"</span>,</div><div class="line">    deeper: {</div><div class="line">        logFoo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">            <span class="built_in">console</span>.log(obj.foo);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">obj.deeper.logFoo(); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/36/" target="_blank" rel="external">示例</a></p>
<h2 id="DOM_事件回调中的this">DOM 事件回调中的<code>this</code></h2>
<p>在DOM事件的处理函数中，<code>this</code>指代的是被绑定该事件的DOM元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listener</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).addEventListener(<span class="string">"click"</span>,</div><div class="line">       <span class="keyword">this</span>.handleClick);</div><div class="line">}</div><div class="line">Listener.prototype.handleClick = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs "&lt;div id="foo"&gt;&lt;/div&gt;"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> Listener();</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click();</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/37/" target="_blank" rel="external">示例</a></p>
<p>…除非你通过<code>bind</code>人为改变了事件处理器的执行上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Listener</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).addEventListener(<span class="string">"click"</span>, </div><div class="line">        <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>));</div><div class="line">}</div><div class="line">Listener.prototype.handleClick = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs Listener {handleClick: function}</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> Listener();</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click();</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/38/" target="_blank" rel="external">示例</a></p>
<h2 id="HTML中的this">HTML中的<code>this</code></h2>
<p>HTML标签的属性中是可以写JS的，这种情况下<code>this</code>指代该HTML元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"foo"</span> <span class="attribute">onclick</span>=<span class="value">"console.log(this);"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"foo"</span>).click(); <span class="comment">//logs &lt;div id="foo"...</span></div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/40/" target="_blank" rel="external">示例</a></p>
<h2 id="重写this">重写<code>this</code></h2>
<p>无法重写<code>this</code>，因为它是一个关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> <span class="keyword">this</span> = {};  <span class="comment">// Uncaught SyntaxError: Unexpected token this </span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/41/" target="_blank" rel="external">示例</a></p>
<h2 id="eval中的this"><code>eval</code>中的<code>this</code></h2>
<p><code>eval</code>中也可以正确获取当前的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> <span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">eval</span>(<span class="string">"console.log(this.foo)"</span>); <span class="comment">//logs "bar"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo();</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/43/" target="_blank" rel="external">示例</a></p>
<p>这里存在安全隐患。最好的办法就是避免使用<code>eval</code>。</p>
<p>使用<code>Function</code>关键字创建的函数也可以获取<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> <span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.foo);"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo(); <span class="comment">//logs "bar"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/44/" target="_blank" rel="external">示例</a></p>
<h2 id="使用with时的this">使用<code>with</code>时的<code>this</code></h2>
<p>使用<code>with</code>可以将<code>this</code>人为添加到当前执行环境中而不需要显示地引用<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span> <span class="params">()</span> </span>{</div><div class="line">}</div><div class="line">Thing.prototype.foo = <span class="string">"bar"</span>;</div><div class="line">Thing.prototype.logFoo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">with</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="built_in">console</span>.log(foo);</div><div class="line">        foo = <span class="string">"foo"</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</div><div class="line">thing.logFoo(); <span class="comment">// logs "bar"</span></div><div class="line"><span class="built_in">console</span>.log(thing.foo); <span class="comment">// logs "foo"</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/45/" target="_blank" rel="external">示例</a></p>
<p>正如很多人认为的那样，很多人认为使用<code>with</code>是不好的，因为会产生歧义。</p>
<h2 id="jQuery中的this">jQuery中的<code>this</code></h2>
<p>一如HTML DOM元素的事件回调，jQuery库中大多地方的<code>this</code>也是指代的DOM元素。页面上的事件回调和一些便利的方法比如<code>$.fn.each</code>（译注：原文为<code>$.each</code>，是错误的，下面的示例代码也体现了应该是jQuery对象上的方法<code>$.fn.each</code>，感谢<a href="https://github.com/leeyeh" target="_blank" rel="external">@leeyeh</a>发现）都是这样的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"foo bar1"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"foo bar2"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">$(<span class="string">".foo"</span>).each(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs &lt;div class="foo...</span></div><div class="line">});</div><div class="line">$(<span class="string">".foo"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//logs &lt;div class="foo...</span></div><div class="line">});</div><div class="line">$(<span class="string">".foo"</span>).each(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.click();</div><div class="line">});</div><div class="line"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/47/" target="_blank" rel="external">示例</a></p>
<h2 id="传递_this">传递 <code>this</code></h2>
<p>如果你用过<a href="http://underscorejs.org/" target="_blank" rel="external">underscore.js</a>或者<a href="http://lodash.com/" target="_blank" rel="external">lo-dash</a>你便知道，这两个库中的很多方法允许你传递一个参数来显式指定执行的上下文。比如<code>_.each</code>。自ECMAScript 5标准后，一些原生的JS方法也允许传递上下文参数，比如<code>forEach</code>。事实上，上文提到的<code>bind</code>，<code>apply</code>还有<code>call</code>已经给我们手动指定函数执行上下文的能力了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thing</span><span class="params">(type)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.type = type;</div><div class="line">}</div><div class="line">Thing.prototype.log = <span class="function"><span class="keyword">function</span> <span class="params">(thing)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type, thing);</div><div class="line">}</div><div class="line">Thing.prototype.logThings = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>{</div><div class="line">   arr.forEach(<span class="keyword">this</span>.log, <span class="keyword">this</span>); <span class="comment">// logs "fruit apples..."</span></div><div class="line">   _.each(arr, <span class="keyword">this</span>.log, <span class="keyword">this</span>); <span class="comment">//logs "fruit apples..."</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing(<span class="string">"fruit"</span>);</div><div class="line">thing.logThings([<span class="string">"apples"</span>, <span class="string">"oranges"</span>, <span class="string">"strawberries"</span>, <span class="string">"bananas"</span>]);</div></pre></td></tr></table></figure>

<p><a href="http://jsfiddle.net/btipling/25xkmho7/50/" target="_blank" rel="external">示例</a></p>
<p>这样可以使得代码简洁些，不用层层嵌套<code>bind</code>，也不用不断地缓存<code>this</code>。</p>
<p>一些编程语言上手很简单，比如<a href="http://golang.org/" target="_blank" rel="external">Go语言手册</a>可以被快速读完。然后你差不多就掌握这门语言了，只是在实战时会有些小的问题或陷阱在等着你。</p>
<p>而JavaScript不是这样的。手册难读。非常多缺陷在里面，以至于人们抽离出了<code>JavaScript精粹</code>（<a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="external">The Good Parts</a>）。最好的文档可能是<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="external">MDN</a>上的了。所以我建议你看看那上面关于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external"><code>this</code></a>的介绍，并且始终在搜索JS相关问题时加上”mdn” 来获得最好的文档资料。静态代码检查也是极好的，比如<a href="http://www.jshint.com/" target="_blank" rel="external">jshint</a>。</p>
<p>欢迎勘误及讨论，我的推特@bjorntipling。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>原文：<a href="http://bjorn.tipling.com/all-this" target="_blank" rel="external">all this</a><br>审阅校对：<a href="https://github.com/leeyeh" target="_blank" rel="external">leeyeh</a></p>
</blockquote>
<p>习惯了传统语言的你或许觉得JavaScript中的<code>this</code>跟Java这些面向对象语言相似，保存了实体属性的一些值。其实不然。将它视作<a href="http://harrypotter.wikia.com/wiki/Boggart" target="_blank" rel="external">幻影魔神</a>比较恰当，手提一个装满未知符文的<a href="http://harrypotter.wikia.com/wiki/Undetectable_Extension_Charm" target="_blank" rel="external">灵龛</a>。</p>
<p>以下内容我希望大家都来了解。全是掏箱底的干货，其中大部分占用了我很多时间才掌握。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://jsbear.baidu.com/tags/javascript/"/>
    
      <category term="this" scheme="http://jsbear.baidu.com/tags/this/"/>
    
      <category term="译文" scheme="http://jsbear.baidu.com/categories/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于请求被挂起页面加载缓慢问题的追查]]></title>
    <link href="http://jsbear.baidu.com/2014/12/31/chrome-request-stalled-problem/"/>
    <id>http://jsbear.baidu.com/2014/12/31/chrome-request-stalled-problem/</id>
    <published>2014-12-31T20:38:22.000Z</published>
    <updated>2015-01-25T13:09:40.586Z</updated>
    <content type="html"><![CDATA[<p>本文前戏较多，务实的同学可以直接跳到结论。</p>
<a id="more"></a>

<p>由「<a href="http://movie.douban.com/subject/4876722/" target="_blank" rel="external">钢的琴</a>」网友脑洞大开延伸出了吉的他二的胡琵的琶，以及后来许嵩的「<a href="http://music.douban.com/subject/6033105/" target="_blank" rel="external">苏格拉没有底</a>」，是否可以再拓展一下，得到哥本不爱吃哈根，哈根爱达斯等剧情乱入的关系。</p>
<p>上面跟本文要讨论的主题有什么关系？</p>
<p>没关系。</p>
<h2 id="缘起">缘起</h2>
<p>有用户反馈内部MIS系统慢，页面加载耗时长。前端同学们开组会提及此事，如何解决慢的问题。</p>
<p>最致命的是：偶发！你不能准确知道它抽风的时间点，无法在想要追查问题的时候必现它。<br>这只是一方面，另外，慢的可能实在太多了，那么问题来了，是前端导致的还是后端的问题？</p>
<p>对慢的定义也有待商榷，多久算慢？如果这个页面加载大量数据耗时增加那我认为这是正常的。但这个时限超过了一个合理的自然值，就变得不那么正常了，比如四五十秒，一分多钟。</p>
<p>最奇葩的是，如此久的耗时居然不会报超时错误，而是拿到正确返回后将页面呈现了出来！</p>
<h2 id="可能的原因">可能的原因</h2>
<h3 id="初步猜测">初步猜测</h3>
<p>初步的猜测可能是后端迟迟未返回造成浏览器处于等待状态。这个猜测是很合乎逻辑的，至少能够很合理地解释Chrome Dev Tool 网络面板中我们看到的状态<code>pending</code>。<br><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/pending.jpg" alt=""></p>
<p>但我们不能停留在猜测阶段，要用事实说话，数据才不会骗人。这也正是本文将要展开的。</p>
<p>下面是另外一些被提出来的可能性。</p>
<h3 id="Angular">Angular</h3>
<p>Angular首当其冲。为什么，因为这个问题出现在后台MIS系统中，且这些系统多用Angular开发。</p>
<p>Angular ：怪我咯。</p>
<p>因为问题多出现在基于Angular的MIS系统中，并且Angular的性能一直是被诟病的，所以听到不少的声音将矛头指向Angular。这似乎没什么好庇护的。Angular在整个项目中的前端部分扮演了很重的角色。树大招风，理所当然。</p>
<p>这让我想起初次接触到这个问题时，那是在七月份，芙蓉的爱马仕平台用户反馈了慢的问题，报到前端，顺便看了下，一看<code>Pending</code>状态，觉得是后端未返回。只是情深缘浅当时也没有深入，同时洪堂大神负责去追查了。当时那个系统，很负责地说，没有用Angular。</p>
<p>所以这里可以为Angular正身，将其排除。</p>
<h3 id="内部封装的commonResource库">内部封装的<code>commonResource</code>库</h3>
<p>内部对Angular原生的<code>resource</code>进行了封装，做了些数据的转换处理。既然上面Angular都被正身了，那么这里的怀疑也是站不住脚的。</p>
<h3 id="Chrome插件">Chrome插件</h3>
<p>经查，网上好多呼声有说是Adblock等与网络有关的Chrome插件。可我不使用它已经很多年，那玩意儿太重，后来找到了算法更高级体量更轻便的<a href="https://chrome.google.com/webstore/detail/%C2%B5block/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en" target="_blank" rel="external">µBlock</a>。关键是后者也在我使用一段时间后放弃了，因为个人觉悟提高了，免费内容是需要广告支撑的，如果你不希望付费变成强制的话。所以现在一直是处于未开这类插件的状态。那么在未开广告屏蔽插件的情况下重现了问题，可以排除这类插件的影响了。</p>
<p>关于插件，此刻我的Chrome里唯一还会接管Chrome网络的便是代理插件<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=en" target="_blank" rel="external">SwitchSharp</a>, 升级之后这货叫<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Switchy哦卖喝</a>（与时俱进的我当然使用的是后者）。</p>
<h3 id="Chrome独家？">Chrome独家？</h3>
<p>因为内部MIS只兼容了Chrome开发，所以不会有在除了Chrome之外的浏览器上使用的场景，并且其他浏览器上面追查问题也是很痛苦的事情。这里仅在火狐里进行了少量尝试，未复现。同时接到反馈，Safari里也未复现。但也不能肯定就只有Chrome存在问题。似乎这个对于问题的解决还不那么重要，所以先不管。</p>
<h3 id="杀毒软件">杀毒软件</h3>
<p>后面会看到，在追查错误号<code>ERR_CONNECTION_RESET</code>时引出了杀毒软件可能会导致Chrome工作不正常的情况，但这个可能也在稍后被排除人。</p>
<p>并且，我厂使用Mac的同学并没有安装杀软，依然是可以复现的。</p>
<h2 id="重现">重现</h2>
<p>第一件事情便是重现。虽然是偶发，为了尽可能保存现场，还是想要手动将它刷出来。天不灭我，经过良久尝试，该问题被复现。于是各种截图，保存请求数据。这个时候还没有开启<code>chrome://net-internals/#events</code>页面来捕获事件日志。</p>
<p>为以后引用方便，这里留下版本信息：</p>
<blockquote>
<p>OS： Windows 7 Ultimate<br>Chrome：Version 39.0.2171.95 m</p>
</blockquote>
<p>这是请求<code>Pending</code>时的请求信息：<br><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/before-response.jpg" alt=""></p>
<p>这是请求成功返回后：<br><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/stalled-timeline.jpg" alt=""></p>
<p>可以看到<code>Stalled</code>了1分多钟。神奇的是竟然不报超时错误而是成功返回了。</p>
<p>同时保存了请求头，响应头，还将本次问题请求保存成了CURL等。现场已经留下，感觉Bug不会存活太久了。</p>
<p>接下来就是对比正常请求跟这次异常请求的不同，一轮比较下来，未发现多少异常。</p>
<h3 id="常态与变态的对比">常态与变态的对比</h3>
<p>请求头对比：</p>
<p>请求头的对比已丢失，但除了时间外，其余无差别。</p>
<p>响应头对比：</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/response-header-compaire.jpg" alt=""></p>
<p>返回结果对比：</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/response.jpg" alt=""></p>
<p>上面的对比意义不大，但还是要做的，万一发现有价值的情报了呢。</p>
<h2 id="一次失败的尝试">一次失败的尝试</h2>
<p>解决问题时，习惯性地看有没有人已经碰过到类似问题，这样做的好处很明显：<br>如果有，站在巨人的肩上轻松地牛逼着；<br>如果没有，这是个机会。</p>
<p>于是信心满满地出发了，因为根据一条互联网准则，70%的问题已经有人解决过了，那些没有被解决的要么是现有技术达不到，要么是未被人发现。所以能够搜索出问题答案的概率还是蛮大的。</p>
<p>经过旷日持久的搜索，有价值的参考寥寥无几。可能是问题本身太过奇葩，遇到的人太少；也有可能问题过于晦涩，无法表述；抑或我搜索的关键词不够精准。<br>倒也不是说一个都没找到，但一般涉及网络日志的情况就无人问津了，无人问津了！</p>
<p>比如<a href="http://stackoverflow.com/questions/14821725/ajax-request-over-https-hangs-for-40-seconds-in-chrome-only" target="_blank" rel="external">这个</a>，一年多前被人问的，现在还没有一个回答。</p>
<p>还比如这个</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource" target="_blank" rel="external">Chrome stalls when making multiple requests to same resource?</a></p>
</blockquote>
<p>是后来作为参考的，也是无人问津了……</p>
<p>甚至自己也去问了<a href="http://stackoverflow.com/questions/27740692/request-stalled-for-a-long-time-occasionally-in-chrome" target="_blank" rel="external">一个</a>，依然无人问津了……</p>
<h3 id="神秘的CACHE_LOCK">神秘的CACHE LOCK</h3>
<p>上面提到，Stackoverflow上找到<a href="http://stackoverflow.com/questions/14821725/ajax-request-over-https-hangs-for-40-seconds-in-chrome-only" target="_blank" rel="external">一个问题</a>，跟现在需要解决一有些类似点：</p>
<ul>
<li>偶发，并不是必然出现的。这里我们的问题也是偶发，很难复现，需要反复刷。</li>
<li>也是请求被<code>Pending</code>了很久，从请求的时间线来看，体现在<code>Stalled</code>上。</li>
</ul>
<p>这一刻，有一种感觉大概是这样的：</p>
<blockquote>
<p>伟大的意大利的左后卫！他继承了意大利的光荣的传统。法切蒂、卡布里尼、马尔蒂尼在这一刻灵魂附体！格罗索一个人他代表了意大利足球悠久的历史和传统，在这一刻他不是一个人在战斗，他不是一个人！</p>
</blockquote>
<p>突然看到了希望。该提问到没有给出什么建设性的意见，但它后面的追加编辑却给出了答案。过程是查看Chrome的网络日志，在事件里面发现有一个超时错误：</p>
<blockquote>
<p>t=33627 [st=    5]      HTTP_CACHE_ADD_TO_ENTRY  [dt=20001]<br>                —&gt; net_error = -409 (ERR_CACHE_LOCK_TIMEOUT)</p>
</blockquote>
<p>耗时20秒之久！而且写得非常明显是<code>ERR_CACHE_LOCK_TIMEOUT</code>。根据提问者贴出来的链接，了解到Chrome有一个缓存锁的机制。</p>
<p>具体源于一个今年6月分实现的一个<a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">补丁</a>，加入了这么个机制，而这个机制的引入又源于2010年的一个issue。具体信息可以通过这个<a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">这里</a>查看，下面引用如下。</p>
<blockquote>
<p>Basically here is the situation:</p>
<p>The site author has a long-lived XHR being used to stream a slow response from the server. This XHR response is cachable (it is just really slow). They kick off the XHR asynchronously, and as data slowly arrives on it, update the progressive load of the webpage. Cool.</p>
<p>Now what happens if you try to load this page in multiple tabs of Chrome is:<br>The first page starts to load just fine, but the second one does nothing.<br>What has happened, is the background XHR of the first page load has acquired an exclusive lock to the cache entry, and the background XHR of the second page is stalled at “Waiting for cache…” trying to get a reader access to the cache entry.</p>
<p>Since the first request can takes minutes, this is a problem.</p>
</blockquote>
<p><a href="mailto:eroman@chromium.org" target="_blank" rel="external">eroman</a> 同学指出了这么一个事实：</p>
<p>浏览器对一个资源发起请求前，会先检查本地缓存，此时这个请求对该资源对应的缓存的读写是独占的。那么问题来了，试想一下，当我新开一个标签尝试访问同一个资源的时候，这次请求也会去读取这个缓存，假设之前那次请求很慢，耗时很久，那么后来这次请求因为无法获取对该缓存的操作权限就一直处于等待状态。这样很不科学。于是有人建议优化一下。也就是上面所描述的那样。</p>
<p>随着问题的提出，还出了两种可能的实现方案。</p>
<blockquote>
<p>(a) [Flexible but complicated] Allow cache readers WHILE writing is in progress. This way the first request could still have exclusive access to the cache entry, but the second request could be streamed the results as they get written to the cache entry. The end result is the second page load would mirror the progress of the first one.</p>
<p>(a) [Naive but simpler] Have a timeout on how long we will block readers waiting for a cache entry before giving up and bypassing the cache.</p>
</blockquote>
<p>我猜上面第二个<code>(a)</code>应该是<code>(b)</code>。简单说第一种优化方案更加复杂但科学。之前的请求对缓存仍然是独占的，但随着前一次请求不断对缓存进行更新，可以把已经更新的部分拿给后面的请求读取，这样就不会完全阻塞后面的请求了。</p>
<p>第二种方案则更加简单暴力。给后来的请求设定一个读取缓存超时的时限，如果超过了这个时限，我认为缓存不可用或者本地没有缓存，忽略这一步直接发请求。</p>
<p>于是Chromium的开发者们选择了后者简单的实现。也就是<a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">Issue 345643003: Http cache: Implement a timeout for the cache lock</a> 这个提交里的实现。</p>
<p>这个提交的描述如下：</p>
<blockquote>
<p>The cache has a single writer / multiple reader lock to avoid downloading the same resource n times. However, it is possible to block many tabs on the same resource, for instance behind an auth dialog.</p>
<p>This CL implements a 20 seconds timeout so that the scenario described in the bug results in multiple authentication dialogs (one per blocked tab) so the user can know what to do. It will also help with other cases when the single writer blocks for a long time.</p>
<p>The timeout is somewhat arbitrary but it should allow medium size resources to be downloaded before starting another request for the same item. The general solution of detecting progress and allow readers to start before the writer finishes should be implemented on another CL.</p>
</blockquote>
<p>于是就产生了上面题主遇到的情况。</p>
<p>所以他的解决方法就很明朗了，对请求加个时间戳让其变得唯一，或者服务器响应头设置为无缓存。Both will work!</p>
<p>那么我们的问题也会是这样的么？我幻想由于某种未知的原因造成之前的请求不正常（虽然网络面板里没有数据证明这样的阻塞请求在问题请求之前存在），然后我们的MIS里打开页面时读取不到缓存，卡了，一会儿缓存好了，正常了，于是在等待了几十秒后请求成功发出去了。</p>
<p>似乎不太可能。因为恰好内部MIS系统的响应头里已经加了缓存控制了 <code>Cache-Control: no-cache</code>。</p>
<p>以下是一次问题请求的响应头：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></div><div class="line"><span class="attribute">Date</span>: <span class="string">Wed, 31 Dec 2014 11:47:21 GMT</span></div><div class="line"><span class="attribute">Content-Type</span>: <span class="string">application/json; charset=UTF-8</span></div><div class="line"><span class="attribute">Transfer-Encoding</span>: <span class="string">chunked</span></div><div class="line"><span class="attribute">Connection</span>: <span class="string">keep-alive</span></div><div class="line"><span class="attribute">Expires</span>: <span class="string">Thu, 19 Nov 1981 08:52:00 GMT</span></div><div class="line"><span class="attribute">Pragma</span>: <span class="string">no-cache</span></div><div class="line"><span class="attribute">Cache-Control</span>: <span class="string">no-cache</span></div><div class="line"><span class="attribute">tracecode</span>: <span class="string">28410188240979065866123119</span></div><div class="line"><span class="attribute">tracecode</span>: <span class="string">28410188240506537994123119</span></div><div class="line"><span class="attribute">Server</span>: <span class="string">Apache</span></div></pre></td></tr></table></figure>

<p>并且开多个标签也是无法进行有效重现的。</p>
<p>因此可以排除缓存的干扰。那么似乎这里的缓存锁并不是导致问题的原因，只能另寻他路。不得不说，高兴过后有点失望。</p>
<h3 id="八卦时间">八卦时间</h3>
<p>可喜的是，在细细口味了上面缓存机制引入的过程后，真是耐人寻味。这里不妨八卦一下。相信你也注意到了，上面提到，该<a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">缓存问题</a>的提出是在2010年，确切地说是<code>Jun 8, 2010</code>。是的，2010年6月8日由<a href="mailto:eroman@chromium.org" target="_blank" rel="external">eroman</a> 同学提出。但最后针对该问题进行修复的代码<a href="https://src.chromium.org/viewvc/chrome?revision=279326&amp;view=revision" target="_blank" rel="external">提交</a>却是在今年6月份，2014年6月24日，提交时间摆在那里我会乱说？</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/cache-fix-commit.jpg" alt=""></p>
<p>于是好奇为什么会拖了这么久，遂跟了一下该问题下面的回复看看发生了什么。简直惊呆了。</p>
<ul>
<li><p>同月14号，有了首次对这个问题的回复，那是将该问题指派给了<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学。</p>
</li>
<li><p>一个月过去了，也就是7月15号，<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学指出了与该问题关联的另外一个issue「<a href="https://code.google.com/p/chromium/issues/detail?id=6697" target="_blank" rel="external">issue 6697</a>」</p>
</li>
<li><p>接下来是8月5日，<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学为该问题贴上了标签<code>-Mstone-7 Mstone-8</code>，表明将会在里程碑7或者8里面进行修复。但在后面的10月7日，这个日程又被推到了<code>-Mstone-8 Mstone-9</code>。</p>
</li>
<li><p>再接下来11月5日，有人表示以目前的速度及bug数量，还没有时间来修复它，重点在处理优先级为<code>p1</code>的问题上。于是此问题又成功被顺延了，来到<code>-mstone-9 Mstone-10</code>，同时优级降为<code>p2</code>。Chromium人手也不够啊，看来。</p>
</li>
<li><p>时间来到12月9日，因为优先级为<code>p2</code>的issue如果没有被标为开始状态的话又自动推到下一个里程碑了，于是顺利来到 <code>-Mstone-10 MovedFrom-10 Mstone-11</code>。次年2月来到<code>-Mstone-11 Mstone-12</code>。完成了一次跨年！</p>
</li>
</ul>
<p>…………</p>
<ul>
<li><p>上面省略N步。如此反复，最后一次被推到了<code>-Mstone-16</code>，那是在2011年10月12日。</p>
</li>
<li><p>时间一晃来到2013年，这一年很平静，前面的几个月都没有人对此问题进行回复。直到11月27日，有人看不下去了，评论道：</p>
</li>
</ul>
<blockquote>
<p>This bug has been pushed to the next mstone forever…and is blocking more bugs (e.g <a href="https://code.google.com/p/chromium/issues/detail?id=31014)and" target="_blank" rel="external">https://code.google.com/p/chromium/issues/detail?id=31014)and</a> use-cases same video in 2 tags on one page, and adaptive bit rate html5 video streaming whenever that will kick in. Any chance this will be prioritized?</p>
</blockquote>
<p>由于这个bug的无限后延也阻塞了另外一些同类问题，看来是时候解决了。这不，最初的owner 当天就进行了回复：</p>
<blockquote>
<p>ecently there was someone looking at giving it another try… I’d have to see if there was any progress there.</p>
<p>If not, I may try to fix it in Q1.</p>
</blockquote>
<p>最后一句亮瞎。敢情这之前owner就没有想过要去真正解决似的，因为有其他人在看这个问题了，所以就没管了，如果Q1还没人解决的话，我会出手的！嗯，就是这个意思。</p>
<p>…………</p>
<p>最后，也就是上文提到的，2014年6月，还是<a href="mailto:rvargas@chromium.org" target="_blank" rel="external">rvargas</a>同学对这个问题进行了修复，实现了对缓存读取20秒超时的控制。</p>
<p>该问题就是这样从2010来到2014的。我怀疑Chrome是如何成为版本帝的。</p>
<h3 id="阶段总结">阶段总结</h3>
<p>仅有的希望到此似乎都没有了。不过前面的努力也不是没有作何收获，至少我得到了以下有价值的信息：</p>
<ul>
<li>谷歌的神坛光环不再那么耀眼，他们的产品也是有Bug的</li>
<li>Chrome 处理issue的效率，当然不排除这种大型项目bug数量跟人力完全不匹配的情况</li>
<li>受上面Stackoverflow问题的启发，接下来我将重点转移到了针对出问题请求的日志分析上，并且取得了突破</li>
</ul>
<h2 id="开始新的征程">开始新的征程</h2>
<p>虽然上面的努力没能定位到问题，但作为这次对解决这次问题的尝试，还是将它记录了下来，估且称作「旧的回忆」吧。</p>
<p>下面开始「新的征程」。</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/new-journey.jpg" alt=""></p>
<h2 id="再次重现">再次重现</h2>
<p>这次受到上面的启发，开启<code>chrome://net-internals/#events</code>页面来捕获事件日志。看是否有错误或异常发生。</p>
<p>再次经过旷日持久的机械操作，重现了！这次，日志在手，天下我有。感觉Bug不会存活多久了。</p>
<p>Chrome Dev Tools 网络面板截图：<br><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/timeline-screen-capture2.jpg" alt=""></p>
<p>由上面的截图看到，本次出问题的请求总耗时42.74秒。</p>
<p>问题请求的时间线信息截图：<br><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/timeline-screen-capture.jpg" alt=""></p>
<p>可以预见，通过捕获的日志完全可以看到<code>Stalled</code>那么久都发生了些什么鬼。</p>
<p>话不多说，切换到事件捕获页面，定位到出问题的请求，查看其详情。同时将该日志导出，永久保存！作为纪念，也方便以后再次导入查看。有兴趣的同学可以访问下方下载后进行导入，就可以清晰地查看到现场了，就好像你亲历了整个犯罪现场一样。</p>
<h3 id="日志还原">日志还原</h3>
<ul>
<li><p><a href="https://gist.githubusercontent.com/wayou/39772215d075c80d643a/raw/9c91463f22016d20c90de19e77ae3e4f302e0769/gistfile1.txt" target="_blank" rel="external">下载该日志文件</a></p>
</li>
<li><p>在Chrome新开一个标签输入<code>chrome://net-internals/#events</code></p>
</li>
<li>切换到<code>Import</code>，选择刚才下载的JSON文件进行导入</li>
<li>切换到<code>Events</code>，定位到<code>http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593</code> 这个请求</li>
</ul>
<p>此刻右边出现的便是该问题请求的详细日志。</p>
<h3 id="日志解读">日志解读</h3>
<p>下面不妨把日志文件贴出来先：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="number">193486</span>: URL_REQUEST</div><div class="line"><span class="label">http:</span>//qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span></div><div class="line">Start Time: <span class="number">2015</span>-<span class="number">01</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">05.323</span></div><div class="line"></div><div class="line">t=    <span class="number">1</span> [<span class="literal">st</span>=    <span class="number">0</span>] +REQUEST_ALIVE  [<span class="pseudo">dt</span>=<span class="number">42741</span>]</div><div class="line">t=    <span class="number">1</span> [<span class="literal">st</span>=    <span class="number">0</span>]    URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">1</span> [<span class="literal">st</span>=    <span class="number">0</span>]   +URL_REQUEST_START_JOB  [<span class="pseudo">dt</span>=<span class="number">42740</span>]</div><div class="line">                      --&gt; load_flags = <span class="number">339804160</span> (BYPASS_DATA_REDUCTION_PROXY | MAYBE_USER_GESTURE | REPORT_RAW_HEADERS | VERIFY_EV_CERT)</div><div class="line">                      --&gt; method = <span class="string">"GET"</span></div><div class="line">                      --&gt; priority = <span class="string">"LOW"</span></div><div class="line">                      --&gt; url = <span class="string">"http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593"</span></div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      HTTP_CACHE_GET_BACKEND  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      HTTP_CACHE_OPEN_ENTRY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      HTTP_CACHE_ADD_TO_ENTRY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      HTTP_CACHE_READ_INFO  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]      URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">2</span> [<span class="literal">st</span>=    <span class="number">1</span>]     +HTTP_STREAM_REQUEST  [<span class="pseudo">dt</span>=<span class="number">2</span>]</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</div><div class="line">                          --&gt; source_dependency = <span class="number">193488</span> (HTTP_STREAM_JOB)</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]     -HTTP_STREAM_REQUEST</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]     +HTTP_TRANSACTION_SEND_REQUEST  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</div><div class="line">                          --&gt; GET /release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span> HTTP/<span class="number">1.1</span></div><div class="line"><span class="label">                              Host:</span> qa.tieba.baidu.com</div><div class="line"><span class="label">                              Connection:</span> keep-alive</div><div class="line"><span class="label">                              Accept:</span> application/json, text/plain, */*</div><div class="line">                              User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span><span class="comment">; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span></div><div class="line"><span class="label">                              Referer:</span> http://qa.tieba.baidu.com/project/</div><div class="line">                              Accept-Encoding: gzip, deflate, sdch</div><div class="line">                              Accept-Language: en-US,en<span class="comment">;q=0.8</span></div><div class="line"><span class="label">                              Cookie:</span> [<span class="number">268</span> bytes were stripped]</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]     +HTTP_TRANSACTION_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">21301</span>]</div><div class="line">t=    <span class="number">4</span> [<span class="literal">st</span>=    <span class="number">3</span>]        HTTP_STREAM_PARSER_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">21301</span>]</div><div class="line">                          --&gt; net_error = -<span class="number">101</span> (ERR_CONNECTION_RESET)</div><div class="line">t=<span class="number">21305</span> [<span class="literal">st</span>=<span class="number">21304</span>]        HTTP_TRANSACTION_RESTART_AFTER_ERROR</div><div class="line">                          --&gt; net_error = -<span class="number">101</span> (ERR_CONNECTION_RESET)</div><div class="line">t=<span class="number">21305</span> [<span class="literal">st</span>=<span class="number">21304</span>]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=<span class="number">21305</span> [<span class="literal">st</span>=<span class="number">21304</span>]     +HTTP_STREAM_REQUEST  [<span class="pseudo">dt</span>=<span class="number">3</span>]</div><div class="line">t=<span class="number">21307</span> [<span class="literal">st</span>=<span class="number">21306</span>]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</div><div class="line">                          --&gt; source_dependency = <span class="number">193494</span> (HTTP_STREAM_JOB)</div><div class="line">t=<span class="number">21308</span> [<span class="literal">st</span>=<span class="number">21307</span>]     -HTTP_STREAM_REQUEST</div><div class="line">t=<span class="number">21308</span> [<span class="literal">st</span>=<span class="number">21307</span>]     +HTTP_TRANSACTION_SEND_REQUEST  [<span class="pseudo">dt</span>=<span class="number">3</span>]</div><div class="line">t=<span class="number">21308</span> [<span class="literal">st</span>=<span class="number">21307</span>]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</div><div class="line">                          --&gt; GET /release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span> HTTP/<span class="number">1.1</span></div><div class="line"><span class="label">                              Host:</span> qa.tieba.baidu.com</div><div class="line"><span class="label">                              Connection:</span> keep-alive</div><div class="line"><span class="label">                              Accept:</span> application/json, text/plain, */*</div><div class="line">                              User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span><span class="comment">; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span></div><div class="line"><span class="label">                              Referer:</span> http://qa.tieba.baidu.com/project/</div><div class="line">                              Accept-Encoding: gzip, deflate, sdch</div><div class="line">                              Accept-Language: en-US,en<span class="comment">;q=0.8</span></div><div class="line"><span class="label">                              Cookie:</span> [<span class="number">268</span> bytes were stripped]</div><div class="line">t=<span class="number">21311</span> [<span class="literal">st</span>=<span class="number">21310</span>]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=<span class="number">21311</span> [<span class="literal">st</span>=<span class="number">21310</span>]     +HTTP_TRANSACTION_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">21304</span>]</div><div class="line">t=<span class="number">21311</span> [<span class="literal">st</span>=<span class="number">21310</span>]        HTTP_STREAM_PARSER_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">21304</span>]</div><div class="line">                          --&gt; net_error = -<span class="number">101</span> (ERR_CONNECTION_RESET)</div><div class="line">t=<span class="number">42615</span> [<span class="literal">st</span>=<span class="number">42614</span>]        HTTP_TRANSACTION_RESTART_AFTER_ERROR</div><div class="line">                          --&gt; net_error = -<span class="number">101</span> (ERR_CONNECTION_RESET)</div><div class="line">t=<span class="number">42615</span> [<span class="literal">st</span>=<span class="number">42614</span>]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=<span class="number">42615</span> [<span class="literal">st</span>=<span class="number">42614</span>]     +HTTP_STREAM_REQUEST  [<span class="pseudo">dt</span>=<span class="number">12</span>]</div><div class="line">t=<span class="number">42627</span> [<span class="literal">st</span>=<span class="number">42626</span>]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</div><div class="line">                          --&gt; source_dependency = <span class="number">193498</span> (HTTP_STREAM_JOB)</div><div class="line">t=<span class="number">42627</span> [<span class="literal">st</span>=<span class="number">42626</span>]     -HTTP_STREAM_REQUEST</div><div class="line">t=<span class="number">42627</span> [<span class="literal">st</span>=<span class="number">42626</span>]     +HTTP_TRANSACTION_SEND_REQUEST  [<span class="pseudo">dt</span>=<span class="number">2</span>]</div><div class="line">t=<span class="number">42627</span> [<span class="literal">st</span>=<span class="number">42626</span>]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</div><div class="line">                          --&gt; GET /release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span> HTTP/<span class="number">1.1</span></div><div class="line"><span class="label">                              Host:</span> qa.tieba.baidu.com</div><div class="line"><span class="label">                              Connection:</span> keep-alive</div><div class="line"><span class="label">                              Accept:</span> application/json, text/plain, */*</div><div class="line">                              User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span><span class="comment">; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span></div><div class="line"><span class="label">                              Referer:</span> http://qa.tieba.baidu.com/project/</div><div class="line">                              Accept-Encoding: gzip, deflate, sdch</div><div class="line">                              Accept-Language: en-US,en<span class="comment">;q=0.8</span></div><div class="line"><span class="label">                              Cookie:</span> [<span class="number">268</span> bytes were stripped]</div><div class="line">t=<span class="number">42629</span> [<span class="literal">st</span>=<span class="number">42628</span>]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=<span class="number">42629</span> [<span class="literal">st</span>=<span class="number">42628</span>]     +HTTP_TRANSACTION_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">112</span>]</div><div class="line">t=<span class="number">42629</span> [<span class="literal">st</span>=<span class="number">42628</span>]        HTTP_STREAM_PARSER_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">112</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS</div><div class="line">                          --&gt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line"><span class="label">                              Date:</span> Fri, <span class="number">02</span> Jan <span class="number">2015</span> <span class="number">09</span>:<span class="number">51</span>:<span class="number">48</span> GMT</div><div class="line">                              Content-Type: application/json<span class="comment">; charset=UTF-8</span></div><div class="line">                              Transfer-Encoding: chunked</div><div class="line"><span class="label">                              Connection:</span> keep-alive</div><div class="line">                              Cache-Control: no-cache</div><div class="line"><span class="label">                              tracecode:</span> <span class="number">31079600320335034634010217</span></div><div class="line"><span class="label">                              tracecode:</span> <span class="number">31079600320537995786010217</span></div><div class="line"><span class="label">                              Server:</span> Apache</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]      HTTP_CACHE_WRITE_INFO  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]      HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]      HTTP_CACHE_WRITE_INFO  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]      URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]   -URL_REQUEST_START_JOB</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]    URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]    HTTP_TRANSACTION_READ_BODY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]    HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]    HTTP_TRANSACTION_READ_BODY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42741</span> [<span class="literal">st</span>=<span class="number">42740</span>]    HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">42742</span> [<span class="literal">st</span>=<span class="number">42741</span>] -REQUEST_ALIVE</div></pre></td></tr></table></figure>

<p>首先，日志显示的总耗时与上面网络面板截图的总耗时是吻合的，都是42.74秒，说明我们定位正确。</p>
<blockquote>
<p>以下时间均以毫秒计</p>
</blockquote>
<p>日志第一列为时间线，自请求发起时算。<br>第二列为每步操作所逝去的时间，时间差的概念，与第三列里面的<code>dt</code>不同，它会积累前面的耗时。<br>第三列为具体的事件，以及相应事件的耗时<code>dt</code>，此耗时为绝对耗时。</p>
<p><code>+</code>号对应事件开始，<code>-</code>号对应事件结束，也就是说他们必然成对出现。住里是展开后更加详细的子事件。直到不能再细分。</p>
<p>如果说一开始接触到这个日志时手足无措的话，我们来看一下正常情况下的日志是怎样的，有对比才有发现。</p>
<p>以下随便摘取一次正常请求的日志，如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="number">384462</span>: URL_REQUEST</div><div class="line"><span class="label">http:</span>//qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span></div><div class="line">Start Time: <span class="number">2015</span>-<span class="number">01</span>-<span class="number">03</span> <span class="number">20</span>:<span class="number">23</span>:<span class="number">54.698</span></div><div class="line"></div><div class="line">t=<span class="number">1556</span> [<span class="literal">st</span>=  <span class="number">0</span>] +REQUEST_ALIVE  [<span class="pseudo">dt</span>=<span class="number">172</span>]</div><div class="line">t=<span class="number">1556</span> [<span class="literal">st</span>=  <span class="number">0</span>]    URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1556</span> [<span class="literal">st</span>=  <span class="number">0</span>]   +URL_REQUEST_START_JOB  [<span class="pseudo">dt</span>=<span class="number">171</span>]</div><div class="line">                   --&gt; load_flags = <span class="number">335609856</span> (BYPASS_DATA_REDUCTION_PROXY | MAYBE_USER_GESTURE | VERIFY_EV_CERT)</div><div class="line">                   --&gt; method = <span class="string">"GET"</span></div><div class="line">                   --&gt; priority = <span class="string">"LOW"</span></div><div class="line">                   --&gt; url = <span class="string">"http://qa.tieba.baidu.com/release/getReleaseHistory?projectId=fum1.0.593"</span></div><div class="line">t=<span class="number">1557</span> [<span class="literal">st</span>=  <span class="number">1</span>]     +URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">4</span>]</div><div class="line">t=<span class="number">1557</span> [<span class="literal">st</span>=  <span class="number">1</span>]        DELEGATE_INFO  [<span class="pseudo">dt</span>=<span class="number">4</span>]</div><div class="line">                       --&gt; delegate_info = <span class="string">"extension Tampermonkey"</span></div><div class="line">t=<span class="number">1561</span> [<span class="literal">st</span>=  <span class="number">5</span>]     -URL_REQUEST_DELEGATE</div><div class="line">t=<span class="number">1561</span> [<span class="literal">st</span>=  <span class="number">5</span>]      HTTP_CACHE_GET_BACKEND  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1561</span> [<span class="literal">st</span>=  <span class="number">5</span>]      HTTP_CACHE_OPEN_ENTRY  [<span class="pseudo">dt</span>=<span class="number">1</span>]</div><div class="line">                     --&gt; net_error = -<span class="number">2</span> (ERR_FAILED)</div><div class="line">t=<span class="number">1562</span> [<span class="literal">st</span>=  <span class="number">6</span>]      HTTP_CACHE_CREATE_ENTRY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1562</span> [<span class="literal">st</span>=  <span class="number">6</span>]      HTTP_CACHE_ADD_TO_ENTRY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1562</span> [<span class="literal">st</span>=  <span class="number">6</span>]      URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1562</span> [<span class="literal">st</span>=  <span class="number">6</span>]     +HTTP_STREAM_REQUEST  [<span class="pseudo">dt</span>=<span class="number">2</span>]</div><div class="line">t=<span class="number">1564</span> [<span class="literal">st</span>=  <span class="number">8</span>]        HTTP_STREAM_REQUEST_BOUND_TO_JOB</div><div class="line">                       --&gt; source_dependency = <span class="number">384467</span> (HTTP_STREAM_JOB)</div><div class="line">t=<span class="number">1564</span> [<span class="literal">st</span>=  <span class="number">8</span>]     -HTTP_STREAM_REQUEST</div><div class="line">t=<span class="number">1564</span> [<span class="literal">st</span>=  <span class="number">8</span>]     +HTTP_TRANSACTION_SEND_REQUEST  [<span class="pseudo">dt</span>=<span class="number">1</span>]</div><div class="line">t=<span class="number">1564</span> [<span class="literal">st</span>=  <span class="number">8</span>]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS</div><div class="line">                       --&gt; GET /release/getReleaseHistory?projectId=fum1<span class="string">.0</span><span class="string">.593</span> HTTP/<span class="number">1.1</span></div><div class="line"><span class="label">                           Host:</span> qa.tieba.baidu.com</div><div class="line"><span class="label">                           Connection:</span> keep-alive</div><div class="line"><span class="label">                           Accept:</span> application/json, text/plain, */*</div><div class="line">                           User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span><span class="comment">; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span></div><div class="line"><span class="label">                           Referer:</span> http://qa.tieba.baidu.com/project/</div><div class="line">                           Accept-Encoding: gzip, deflate, sdch</div><div class="line">                           Accept-Language: en-US,en<span class="comment">;q=0.8</span></div><div class="line"><span class="label">                           Cookie:</span> [<span class="number">2642</span> bytes were stripped]</div><div class="line">t=<span class="number">1565</span> [<span class="literal">st</span>=  <span class="number">9</span>]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=<span class="number">1565</span> [<span class="literal">st</span>=  <span class="number">9</span>]     +HTTP_TRANSACTION_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">161</span>]</div><div class="line">t=<span class="number">1565</span> [<span class="literal">st</span>=  <span class="number">9</span>]        HTTP_STREAM_PARSER_READ_HEADERS  [<span class="pseudo">dt</span>=<span class="number">160</span>]</div><div class="line">t=<span class="number">1725</span> [<span class="literal">st</span>=<span class="number">169</span>]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS</div><div class="line">                       --&gt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line"><span class="label">                           Date:</span> Sat, <span class="number">03</span> Jan <span class="number">2015</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">54</span> GMT</div><div class="line">                           Content-Type: application/json<span class="comment">; charset=UTF-8</span></div><div class="line">                           Transfer-Encoding: chunked</div><div class="line"><span class="label">                           Connection:</span> keep-alive</div><div class="line">                           Cache-Control: no-cache</div><div class="line"><span class="label">                           tracecode:</span> <span class="number">14346880480340800522010320</span></div><div class="line"><span class="label">                           tracecode:</span> <span class="number">14346880480253893130010320</span></div><div class="line"><span class="label">                           Server:</span> Apache</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]      HTTP_CACHE_WRITE_INFO  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]      HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]      HTTP_CACHE_WRITE_INFO  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]     +URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">1</span>]</div><div class="line">t=<span class="number">1726</span> [<span class="literal">st</span>=<span class="number">170</span>]        DELEGATE_INFO  [<span class="pseudo">dt</span>=<span class="number">1</span>]</div><div class="line">                       --&gt; delegate_info = <span class="string">"extension Tampermonkey"</span></div><div class="line">t=<span class="number">1727</span> [<span class="literal">st</span>=<span class="number">171</span>]     -URL_REQUEST_DELEGATE</div><div class="line">t=<span class="number">1727</span> [<span class="literal">st</span>=<span class="number">171</span>]   -URL_REQUEST_START_JOB</div><div class="line">t=<span class="number">1727</span> [<span class="literal">st</span>=<span class="number">171</span>]    URL_REQUEST_DELEGATE  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1727</span> [<span class="literal">st</span>=<span class="number">171</span>]    HTTP_TRANSACTION_READ_BODY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1727</span> [<span class="literal">st</span>=<span class="number">171</span>]    HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">1</span>]</div><div class="line">t=<span class="number">1728</span> [<span class="literal">st</span>=<span class="number">172</span>]    HTTP_TRANSACTION_READ_BODY  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1728</span> [<span class="literal">st</span>=<span class="number">172</span>]    HTTP_CACHE_WRITE_DATA  [<span class="pseudo">dt</span>=<span class="number">0</span>]</div><div class="line">t=<span class="number">1728</span> [<span class="literal">st</span>=<span class="number">172</span>] -REQUEST_ALIVE</div></pre></td></tr></table></figure>

<p>针对上面正常的请求，我们主要关注两部分，如下面的截图：</p>
<ul>
<li>发送请求头 <code>+HTTP_TRANSACTION_SEND_REQUEST  [dt=1]</code></li>
<li>读取响应头 <code>+HTTP_TRANSACTION_READ_HEADERS  [dt=161]</code></li>
</ul>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/normal-section.jpg" alt=""></p>
<p>这是正常的情况下，没有什么问题。并且日志里可以清晰地看到发送的请求头是什么，然后解析出来的响应头是什么。这跟在网络面板看到的是一致的。</p>
<p>再回到出问题的请求日志上来，同样我们只关注这两部分。如下面的截图：</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/3retry.jpg" alt=""></p>
<p>与正常相比，最后一次发送请求和读取响应头无异常，时间就多在了前面还有再次发送和请求的过程，细看时间都花在了以下两个事件中：</p>
<ul>
<li><code>HTTP_STREAM_PARSER_READ_HEADERS  [dt=21301]</code></li>
<li><code>HTTP_STREAM_PARSER_READ_HEADERS  [dt=21304]</code></li>
</ul>
<p>该事件的名称已经自我解读，意思是解析读取的响应头。但问题是紧接着下面报错了，</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"><span class="input"><span class="prompt">-&gt;</span> net_error = -<span class="number">101</span> (<span class="constant">ERR_CONNECTION_RESET</span>)</span></span></div></pre></td></tr></table></figure>

<p>读取响应头时发生了链接重置的错误，有理由认为本次链接是不成功的，没拿到正确的响应头，于是解析不成功。时间都花在了这里，足足21秒之久，两个21秒造就了上面看到的<code>Stalled</code>了42秒之久。</p>
<p>问题似乎已经很明朗了。链接被重置。</p>
<p>在第三次尝试的时候正常了，于是正确返回，我们才看到了被解析的响应头被展示在了下面。也就是说在出问题的时候要么响应头未拿到，要么响应头非法导致解析不成功。而原因就是链接被重置。</p>
<p>那么接下来的工作就是对<code>ERR_CONNECTION_RESET</code>这个错误的追查了。</p>
<h2 id="官方关于_ERR_CONNECTION_RESET_错误的解释">官方关于 <code>ERR_CONNECTION_RESET</code> 错误的解释</h2>
<p>未找到官方相应的资料，Chrome官网上唯一<a href="https://support.google.com/chrome/answer/117804?hl=en" target="_blank" rel="external">关于此错误的描述</a>是在安装Chrome时出现Error 101。我估计文档的撰写人员没想到谁会这么蛋疼想要看这些生涩的东西，除了开发者。既然你都是开发者了，那为什么不去看Chromium的源码。</p>
<p>好吧，唯一的途径似乎只能从源码中寻找了。作为只精JS的前端人员，现在要从C，C++代码中找答案了。估计追完这个问题，我会尝试为Chromium贡献代码。</p>
<p>慢着，在这之前，还是搜到一些关于这个错误的信息的。但似乎都不怎么靠谱。</p>
<p>比如<a href="http://blog.agmon.com/2013/07/05/solving-error-101-neterr_connection_reset-the-connection-was-reset/" target="_blank" rel="external">这里</a>提到，是因为ISP网络问题，实在无太可能。还有<a href="http://www.tomshardware.com/answers/id-1982982/err-connection-reset-error-chrome.html" target="_blank" rel="external">这是神马</a>居然一个硬件网站但提到了这个错误，并且怀疑是杀软导致Chrome出问题，但杀软已经在上文被我们排除了。</p>
<h2 id="Chromium_源码">Chromium 源码</h2>
<p>那么这个错误究竟是什么。能不能找到点靠谱的解释。当然能，让我们进入到Chromium的源码中去。</p>
<h3 id="ERR_CONNECTION_RESET被唤起的地方">ERR_CONNECTION_RESET被唤起的地方</h3>
<p>在Chromium的源码中搜索该常量名，确实出现很多<a href="https://code.google.com/p/chromium/codesearch#search/&amp;q=ERR_CONNECTION_RESET&amp;sq=package:chromium&amp;type=cs" target="_blank" rel="external">结果</a>。联系到我们查看日志发现问题的上下文，是在解析响应头报的。所以我们定位到<code>http_stream_parser.cc</code>文件，同时注意到有一个文件叫<code>net_errors_win.cc</code>，所以猜测他是定义所有错误常量用的，也顺便打开之。</p>
<p>经过观察<code>src/net/base/net_errors_win.cc</code> 其路径和代码得知其中多为系统级别的错误，似乎跟我们的问题不是很关联，忽略该文件。</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/source.jpg" alt=""></p>
<p><code>http_stream_parser.cc</code>文件中，<code>ERR_CONNECTION_RESET</code>仅出现一次。这给我们定位带来了极大的便利。</p>
<figure class="highlight cpp"><figcaption><span>[chromium]//src/net/base/net_errors_win.cc</span><a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/http/http_stream_parser.cc&q=ERR_CONNECTION_RESET&sq=package:chromium&dr=C" target="_blank" rel="external">http_stream_parser.cc</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns true if |error_code| is an error for which we give the server a</span></div><div class="line"><span class="comment">// chance to send a body containing error information, if the error was received</span></div><div class="line"><span class="comment">// while trying to upload a request body.</span></div><div class="line"><span class="keyword">bool</span> ShouldTryReadingOnUploadError(<span class="keyword">int</span> error_code) {</div><div class="line">  <span class="keyword">return</span> (error_code == ERR_CONNECTION_RESET);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里定义了一个<code>ShouldTryReadingOnUploadError</code> 的方法，注释耐人寻味，这个时候，这样的情景，能否正确解读注释成为了比读懂代码更重要（这是我在看JS代码时永远无法体味到的感觉），下面尽可能对它进行理解：</p>
<blockquote>
<p>在尝试发送一个请求体的时候，让服务器尝试发送一个带错误的响应体，如果我们接收到了该错误则返回<code>true</code></p>
</blockquote>
<p>我承认被上面的复杂从句打败！</p>
<p>那么我们来看这个方法被调用的场景。</p>
<p>现在我们点击上面的<code>ShouldTryReadingOnUploadError</code>方法，代码下方出现调用了该方法的地方，一共有两处。</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/call.jpg" alt=""></p>
<p>分别点击进行查看。</p>
<figure class="highlight cpp"><figcaption><span>459行DoSendHeadersComplete方法里进行了调用</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> HttpStreamParser::DoSendHeadersComplete(<span class="keyword">int</span> result) {</div><div class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">    <span class="comment">// In the unlikely case that the headers and body were merged, all the</span></div><div class="line">    <span class="comment">// the headers were sent, but not all of the body way, and |result| is</span></div><div class="line">    <span class="comment">// an error that this should try reading after, stash the error for now and</span></div><div class="line">    <span class="comment">// act like the request was successfully sent.</span></div><div class="line">    <span class="keyword">if</span> (request_headers_-&gt;BytesConsumed() &gt;= request_headers_length_ &&</div><div class="line">        ShouldTryReadingOnUploadError(result)) {</div><div class="line">      upload_error_ = result;</div><div class="line">      <span class="keyword">return</span> OK;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  }</div></pre></td></tr></table></figure>

<blockquote>
<p>虽然不太可能，但也不排除头部和请求体合并的情况，当所有头部发送完毕，请求体不一定，此时<code>result</code>便是需要稍后处理的一种错误，这里暂且先返回<code>OK</code>。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>516行另一个DoSendBodyComplete方法里进行了调用</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> HttpStreamParser::DoSendBodyComplete(<span class="keyword">int</span> result) {</div><div class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</div><div class="line">    <span class="comment">// If |result| is an error that this should try reading after, stash the</span></div><div class="line">    <span class="comment">// error for now and act like the request was successfully sent.</span></div><div class="line">    <span class="keyword">if</span> (ShouldTryReadingOnUploadError(result)) {</div><div class="line">      upload_error_ = result;</div><div class="line">      <span class="keyword">return</span> OK;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  }</div></pre></td></tr></table></figure>

<blockquote>
<p>跟上面类似，如果<code>result</code>出错，稍后处理，先返回正常</p>
</blockquote>
<p>这也与我们在日志中看到的情况相符，在前面再次错误后，这次请求并没有终止结束，而是尝试到了第三次并且以成功结束的。</p>
<p>但不管怎样，从这两个方法，一个<code>DoSendHeadersComplete</code>， 另一个<code>DoSendBodyComplete</code>，身上能体现出请求确实已经发出去。</p>
<h3 id="TCP_RST">TCP RST</h3>
<p>另外，在<a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/base/net_error_list.h" target="_blank" rel="external"><code>net_error_list.h</code></a>这个文件的109行，可以准确找到我们在日志中得到的101号错误。它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A connection was reset (corresponding to a TCP RST).</span></div><div class="line">NET_ERROR(CONNECTION_RESET, -<span class="number">101</span>)</div></pre></td></tr></table></figure>

<p>从括号中的进一步解释可以知道，它代表TCP连接重置。</p>
<h2 id="TCP">TCP</h2>
<p>那么问题来了，什么是TCP连接重置？什么会引发TCP连接重置。从<a href="http://blogs.technet.com/b/networking/archive/2009/08/12/where-do-resets-come-from-no-the-stork-does-not-bring-them.aspx" target="_blank" rel="external">这篇文章</a>中有比较详细的解答。</p>
<p>想要完全解释，本文似乎是不可能的了。但根据上面的文章，这里可以简单转述一下。</p>
<h3 id="什么是TCP连接">什么是TCP连接</h3>
<p>它是一种协议。当网络上一个节点想与另一个节点通信时，双方需要选建立连接。而这个连接过程需要大家都懂的一种约定，TCP就是事先定好的一种约定，于是我们采用它吧，于是其中一个节点按照这个约定发起一建立连接的请求，另一节点收到后，根据该约定，便能读懂这个请求里各字段的意思：哦，丫这是想约我呢。</p>
<h3 id="三次握手">三次握手</h3>
<p>继续上面的例子。A想与B通信，并且使用TCP。</p>
<p>首先A发起一个报文，其中包含自己的地址，想要连接的目标地址，自己用来连接的端口及目标机器的端口,etc.</p>
<p>B收到邀约，并且愿意付约。此刻B需要回传一个报文，告诉A我愿意跟你连接。</p>
<p>A收到B的肯定应答，到此A与B经历了三次通信或者说是握手，双方都没有异议，连接建立。</p>
<p>而连接断开的过程也颇为类似。双方中的一方比如说A先发起一个断开连接的报文FIN，B收到并确认，然后回传一个可以断开的报文FIN给A。此刻A收到并确认。此刻双方都确认后，连接可以安全断开，但还会保持一个等待断开的状态，大概持续4分钟，用于之前连接通路上未传输完成的数据进行善后。</p>
<h3 id="什么是重置">什么是重置</h3>
<p>上面提到了4分钟的等待时间，而重置RESET便是立即断开连接的手段。</p>
<h3 id="发生重置的情况">发生重置的情况</h3>
<p>到此重置的作用已然明了。也就是说，重置甚至算不上一个错误，它是TCP连接中的一种正常情况。但什么时候会发生重置，如何引起的。</p>
<p>上文列出了三种情况。</p>
<h4 id="SMB_Reset">SMB Reset</h4>
<p>简单举例来说，服务器提供了两个端口445，139进行服务，客户端同时去请求与这两个端口连接，服务器返回了两个端口可以被连接，此刻客户端择优选择一个进行连接，而重置另一个。</p>
<h4 id="Ack,_Reset">Ack, Reset</h4>
<p>报文重置发生主要有以下情况：</p>
<ul>
<li>服务器没有监听被请求的端口，无法建立连接</li>
<li>服务器此刻无法比如没有充裕的资源用来连接连接</li>
</ul>
<h4 id="TCP_Reset_due_to_no_response">TCP Reset due to no response</h4>
<p>由于没有响应而被重置。当发起连接的一方连续发送6次请求未得到回应，此刻默认他们之间已经通过三次握手建立了连接并且通信有问题，发起的一方将连接重置。</p>
<h4 id="Application_Reset">Application Reset</h4>
<p>除了上面的情况，找不到TCP内部自己发送的重置，则归为了这一类。程序内将连接重置。此种情况包含了所有你想得到想不到将连接断开的情况。有可能是程序内部逻辑重置的，所以不能完全认为此时发生了错误。</p>
<p>值得注意的是，上面列出的情况服务器的不确定性导致连接重置的可能性要合理些。Chrome 主动发起URL请求不太可能自己又重置掉，并且没有理由重置掉后又去重连。</p>
<h2 id="进一步解读日志文件">进一步解读日志文件</h2>
<p>上面Chromium源码部分的求证多少带有猜测成分。不妥。</p>
<p>因为没找到关于Chrome net-internal 日志的官方文档什么的，自身去解读始终是有局限的。不如提个ISSUE让Chromium开发人员来搭一把手吧。遂向Chromium提交ISSUE，请<a href="https://code.google.com/p/chromium/issues/detail?id=447463" target="_blank" rel="external">戳此查看</a>，虽然我不认为现在遇到的这个问题跟Chrome有关并且属于Chrome的Bug，目的仅仅是看他们能否帮忙给出合理的日志解读来定位问题。</p>
<p>三天后（有点热泪盈眶），有同学<a href="https://code.google.com/p/chromium/issues/detail?id=447463#c1" target="_blank" rel="external">回复</a>，将日志所体现的问题诊断得似乎很有道理，可信。</p>
<blockquote>
<p>1)  We have a bunch of connections to qa.tieba.baidu.com, all were used successfully, and are now idle.<br>2)  They all silently die for some reason, without us ever being informed.  My guess is your personal router times out the connection, but this could also be your ISP, the destination server, or ever a real network outage (A short one) that prevents us from getting the connection closed message.<br>3)  There’s a new request to qa.tieba.baidu.com.  We try to reuse a socket.  After 21 seconds, we get the server’s RST message (“I don’t have a connection to you.”).  Since it was a stale socket, we’re aware this sometimes happens, so we just retry…And get the next idle socket in the list, which, after 21 seconds, gives us the same reset message.  We try again, for the same reason.  This time we don’t have another stale socket to try, so we use a fresh one.  The request succeeds.</p>
<p>The real problem here is something is taking 21 seconds to send us the RST messages, despite the fact that a roundtrip to the server you’re talking to only takes about 100 milliseconds.</p>
</blockquote>
<ul>
<li><p>「之前有过很多成功的连接」，确实，因为出现加载缓慢的情况是偶发的，这之前有过很多正常的不卡的请求存在过。这里没有异议。</p>
</li>
<li><p>「他们都以未知的原因被断掉了」，因为不是正常地断开连接，所以客户端也就是浏览器不知道当前与服务器的TCP连接已经断开，傻傻地保留着与服务器连接的socket，注意，此时已经发生信息的不对等了，这是问题的根源。至于什么原因，给出了可能的原因：路由器认为连接超时将其断掉，同时不排除ISP（互联网服务提供商）的原因，服务器暂时的停运抽风等。不管怎样，客户端浏览器没有收到连接断开的信息。</p>
</li>
<li><p>在上面的基础上，我们去发起一次新的请求。此时浏览器希望重用之前的连接以节省资源，用之前的一个socket去发起连接。21秒后收到服务器返回的重置信息（意思是服务器告诉浏览器：我和你之间没有连接），没关系，上面提到，我们有很多可以重用的连接，于是浏览器重新从可用的连接里面又选择了一个去进行连接，不幸的是，同样的情况再次发生，21秒后收到服务器的重置信息。这体现在日志上就是第二次重试失败。到第三次，因为前面浏览器认为可以重用的连接现在都被正确地标为断开了，没有新的可用，于是这次浏览器发起了全新的请求，成功了！</p>
</li>
</ul>
<p>总结出来，两个问题：</p>
<ul>
<li>为什么之前成功的连接不正常的断开了？服务器配置或者网络原因？</li>
<li>是什么让浏览器21秒后才收到重置信息？服务器作出反应过慢还是网络原因？</li>
</ul>
<h2 id="Chrome_Dev_Tool_中时间线各阶段代表的意义">Chrome Dev Tool 中时间线各阶段代表的意义</h2>
<p>另附注一下Chrome Dev Tool 中请求的时间线各阶段代表的意义。<br>以下内容扒自<a href="https://developer.chrome.com/devtools/docs/network#resource-network-timing" target="_blank" rel="external">Chrome 开发者文档页</a>，然后我将它本地化了一下下。</p>
<p><img src="/jsbear/asset/posts/2014-12-31-chrome-request-stalled-problem/timing.png" alt=""></p>
<h3 id="Stalled/Blocking">Stalled/Blocking</h3>
<p>在请求能够被发出去前的等等时间。包含了用于处理代理的时间。另外，如果有已经建立好的连接，那么这个时间还包括等待已建立连接被复用的时间，这个遵循Chrome对同一源最大6个TCP连接的规则。</p>
<p>「拿我们的情况来说，上面出错所有的耗时也是算在了这部分里面。网络面板中显示的其余时间比如DNS查找，连接建立等都是属于最后那次成功请求的了」</p>
<h3 id="Proxy_Negotiation">Proxy Negotiation</h3>
<p>处理代理的时间。</p>
<h3 id="DNS_Lookup">DNS Lookup</h3>
<p>查找DNS的时间。页面上每个新的域都需要一次完整的寻路来完成DNS查找。</p>
<h3 id="Initial_Connection_/_Connecting">Initial Connection / Connecting</h3>
<p>用于建立链接的时间，包括TCP握手及多次尝试握手，还有处理SSL。</p>
<h3 id="SSL">SSL</h3>
<p>完成SSL握手的时间。</p>
<h3 id="Request_Sent_/_Sending">Request Sent / Sending</h3>
<p>Time spent issuing the network request. Typically a fraction of a millisecond.</p>
<p>发起请求的时间，通常小到可以忽略。</p>
<h3 id="Waiting_(TTFB)">Waiting (TTFB)</h3>
<p>等待响应的时间，具体来说是等待返回首个字节的时间。包含了与服务器之间一个来回响应的时间和等待首个字节被返回的时间。</p>
<h3 id="Content_Download_/_Downloading">Content Download / Downloading</h3>
<p>用于下载响应的时间</p>
<h2 id="结论">结论</h2>
<p>我相信很多同学是直接跳到这里来了的。事实上我给不出什么解决方案，但能排除前端代码引起问题的可能性。</p>
<p>具体来说，能够得到的结论有以下几点：</p>
<ul>
<li>请求成功构造，失败情况下也可以看到正常的请求头被打印出来了的</li>
<li>可以肯定的是在与服务器建立连接时被Shut down了，参考上面关于连接重置的部分会更有意义一些</li>
</ul>
<p>最后希望RD同跟进，协助排查服务器连接及后端代码的部分。</p>
<p class="text-primary">01/13日更新：参见上面进一步解读日志文件部分。</p>


<h2 id="参考及引用">参考及引用</h2>
<p>#1 <a href="http://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource" target="_blank" rel="external">Chrome stalls when making multiple requests to same resource?</a><br>#2 <a href="http://stackoverflow.com/questions/5585918/what-does-pending-mean-for-request-in-chrome-developer-window" target="_blank" rel="external">What does “pending” mean for request in Chrome Developer Window?</a><br>#3 <a href="https://developer.chrome.com/devtools/docs/network#resource-network-timing" target="_blank" rel="external">Evaluating network performance / Resource network timing</a><br>#4 <a href="https://www.google.com/search?q=Provisional+headers+are+shown&amp;gws_rd=ssl" target="_blank" rel="external">Provisional headers are shown</a><br>#5 <a href="http://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger" target="_blank" rel="external">“CAUTION: provisional headers are shown” in Chrome debugger</a><br>#6 <a href="http://segmentfault.com/q/1010000000364871" target="_blank" rel="external">Chrome 里的请求报错 “CAUTION: Provisional headers are shown” 是什么意思?</a><br>#7 <a href="https://codereview.chromium.org/345643003" target="_blank" rel="external">Issue 345643003: Http cache: Implement a timeout for the cache lock</a><br>#8 <a href="https://code.google.com/p/chromium/issues/detail?id=46104" target="_blank" rel="external">Issue 46104:   Pages can get blocked in “Waiting for Cache” for a very long time</a><br>#9 <a href="http://dev.chromium.org/for-testers/providing-network-details" target="_blank" rel="external">Providing Network Details for bug reports</a><br>#10 <a href="http://div.io/topic/609?page=1#2050" target="_blank" rel="external">从FE的角度上再看输入url后都发生了什么</a><br>#11 <a href="https://code.google.com/p/chromium/codesearch#chromium/src/net/http/http_stream_parser.cc&amp;q=ERR_CONNECTION_RESET&amp;sq=package:chromium&amp;dr=C&amp;l=77" target="_blank" rel="external">ERR_CONNECTION_RESET 的Chromium 源码</a><br>#12 <a href="http://www.chromium.org/developers/design-documents/network-stack#TOC-HttpStreamFactory" target="_blank" rel="external">Chromium Network Stack</a><br>#13 <a href="http://blogs.technet.com/b/networking/archive/2009/08/12/where-do-resets-come-from-no-the-stork-does-not-bring-them.aspx" target="_blank" rel="external">Where do resets come from? (No, the stork does not bring them.)</a><br>#14 <a href="https://code.google.com/p/chromium/issues/detail?id=447463#c1" target="_blank" rel="external">Issue 447463: Chrome-network: Long delay before RST message on stale sockets results in slow page loads)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文前戏较多，务实的同学可以直接跳到结论。</p>
]]>
    
    </summary>
    
      <category term="Chrome" scheme="http://jsbear.baidu.com/tags/Chrome/"/>
    
      <category term="网络请求" scheme="http://jsbear.baidu.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="技术" scheme="http://jsbear.baidu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object.observe() —— 数据绑定的革命]]></title>
    <link href="http://jsbear.baidu.com/2014/12/08/observe%20/"/>
    <id>http://jsbear.baidu.com/2014/12/08/observe /</id>
    <published>2014-12-08T00:00:00.000Z</published>
    <updated>2015-01-25T13:09:40.586Z</updated>
    <content type="html"><![CDATA[<p>作者：Addy Osmani</p>
<p>发布日期： 2014年5月20日</p>
<p>更新： 2014年5月20日</p>
<p>翻译：刘凯</p>
<a id="more"></a>

<p>审阅校对：李叶，余尔威，刘勇</p>
<p>原文：<a href="http://www.html5rocks.com/en/tutorials/es7/observe/" target="_blank" rel="external">Data-binding Revolutions with Object.observe()</a></p>
<h2 id="介绍">介绍</h2>
<p>一场革命正在来临。JavaScript增加了一个新机能，其将改变以往你对数据绑定的所有认知。它也将会改变当今的MVC框架实现监听数据模型编辑、更新行为的方法。那些关注属性监听的应用将会得到性能上的提升，你准备好了吗？</p>
<p>好了，赶快进入正题吧。我很高兴地宣布，「<code>Object.observe()</code>」正式在Chrome 36 稳定版中可用了。【哇哦~此处应该有掌声】</p>
<p><code>Object.observe()</code>，作为未来ECMAScript标准的一部分，是一个用于异步监听JavaScript对象变化的方法，并且无需使用额外的JavaScript库。它允许监听器接受一个按时间顺序排列的变更记录序列，这些变更记录描述了被监听对象所发生变化的内容的集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设我们这里有个数据模型</span></div><div class="line"><span class="keyword">var</span> model = {};</div><div class="line"><span class="comment">// 我们来对它进行监听</span></div><div class="line"><span class="built_in">Object</span>.observe(model, <span class="function"><span class="keyword">function</span><span class="params">(changes)</span></span>{</div><div class="line">    <span class="comment">// 这个异步回调函数将被执行</span></div><div class="line">    changes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(change)</span> </span>{</div><div class="line">        <span class="comment">// 我们知道了都发生了哪些变化</span></div><div class="line">        <span class="built_in">console</span>.log(change.type, change.name, change.oldValue);</div><div class="line">    });</div><div class="line">});</div></pre></td></tr></table></figure>

<p>数据模型发生的任何变化都会被记录下来：</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_0.png" alt=""></p>
<p>通过<code>Object.observe()</code>（我更喜欢称它为O.o()或Ooooooo)，你可以在<a href="http://bitworking.org/news/2014/05/zero_framework_manifesto" target="_blank" rel="external">不使用任何框架</a>的前提下轻松实现双向数据绑定。</p>
<p>当然这并不是说你不应该使用它们。对于那些业务逻辑复杂的大工程，这些框架还是非常有价值的。它们缩小了开发者的关注面，减少了需要维护的代码，并且固化了常见任务的实现模式。如果不需要，你也可以选择一些更小更具针对性的库，比如<a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a>（它已经是O.o()的受益者了）。</p>
<p>即使你发现自己正重度依赖一些框架或MV*库，O.o()也有可能以一个更快更简单的实现改善他们的性能，并同时保证API不变。举个例子，去年Angular进行了一个监听模型变化的<a href="https://mail.mozilla.org/pipermail/es-discuss/2012-September/024978.html" target="_blank" rel="external">测试</a>。在benchmark上，使用脏检查的话每次更新需要耗费40毫秒，而O.o()只花了1~2毫秒（足足快了20~40倍）。</p>
<p>数据绑定不再需要一大堆的复杂代码，也意味着不再需要通过轮询来发现变化，因此也就意味着更长的电池续航！</p>
<p>如果你已经爱上了O.o()，那么你可以跳到后面的特性介绍，或继续看看它都解决了哪些问题。</p>
<h2 id="我们都想要监听些什么？">我们都想要监听些什么？</h2>
<p>当我们谈起数据监听时，通常是指观察一些特定的变化：</p>
<ul>
<li>JavaScript原生对象的改变</li>
<li>属性的添加、变动、删除</li>
<li>数组元素的添加或移除</li>
<li>对象原型的改变</li>
</ul>
<h2 id="数据绑定的重要性">数据绑定的重要性</h2>
<p>当你关注模型-视图的控制分离时，数据绑定就变得非常重要。HTML是一个很好的声明机制，但它完全是静态的。理想情况下，你希望只声明数据与DOM之间的关系，就能够让DOM保持最新。你将不再需要编写那些仅仅是在DOM和你的应用内部状态或服务器间进行数据交换的代码，从而节省大量的时间。</p>
<p>如果你的用户界面较为复杂，你需要维护数据模型中的多个属性与页面中多个元素的关系，这时数据绑定的优势尤为明显。这在当今的单页应用中非常普遍。</p>
<p>通过浏览器原生的数据监听，我们给予了JavaScript框架（还有你正在编写的小工具库）监听模型中数据变化的方法，且不用依赖我们现在正在使用的一些hack方法。</p>
<h2 id="现状是什么样的">现状是什么样的</h2>
<h3 id="脏检查">脏检查</h3>
<p>你以前在哪见过数据绑定？好吧，如果你用过现代MV*库来构建你的网页应用（比如Angular，Knockout），你可能已习惯了将模型数据绑定到DOM上。我们来复习一下，这有个手机列表应用的例子，我们要把「phones」数组（在JS中定义的）中的每个「phone」的值绑定到一个列表项上，这样我们的数据和用户界面总能保持同步：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">ng-app</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"angular.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"controller.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-controller</span>=<span class="value">"PhoneListCtrl"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"phone in phones"</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="title">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>


<p>下面是控制器的JS代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> phonecatApp = angular.module(<span class="string">'phonecatApp'</span>, []);</div><div class="line">phonecatApp.controller(<span class="string">'PhoneListCtrl'</span>, <span class="function"><span class="keyword">function</span><span class="params">($scope)</span> </span>{</div><div class="line">  $scope.phones = [</div><div class="line">    {<span class="string">'name'</span>: <span class="string">'Nexus S'</span>,</div><div class="line">     <span class="string">'snippet'</span>: <span class="string">'Fast just got faster with Nexus S.'</span>},</div><div class="line">    {<span class="string">'name'</span>: <span class="string">'Motorola XOOM with Wi-Fi'</span>,</div><div class="line">     <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span>},</div><div class="line">    {<span class="string">'name'</span>: <span class="string">'MOTOROLA XOOM'</span>,</div><div class="line">     <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span>}</div><div class="line">  ];</div><div class="line">});</div></pre></td></tr></table></figure>


<p><a href="http://angular.github.io/angular-phonecat/step-2/app/" target="_blank" rel="external">( Demo )</a></p>
<p>一旦底层的模型数据发生变化，我们DOM中的列表就会相应更新。Angular是怎么做到的？它在底层进行着「脏检查」的工作。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_1.png" alt=""></p>
<p>脏检查的基本思想是，一旦数据可能发生改变，库就要通过摘要循环或变化循环去检查是否发生了变化。在Angular中，一次摘要循环会检查所有需要监听的表达式，看是否发生了变化。它<a href="http://stackoverflow.com/questions/9682092/databinding-in-angularjs/9693933#9693933" target="_blank" rel="external">知道</a>模型的前一个值是什么，当变化发生时，会触发一个「change」事件。对开发者来说，最大的好处莫过于你可以使用原生的JavaScript对象（用起来写起来都很爽）。而缺点就是它的算法比较糟糕，并且可能有很大的开销。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_2.png" alt="enter image description here"></p>
<p>该操作的开销与被监视的对象的数量是成正比的。我可以进行大量的脏检查，也可以找到一种方法，在数据「可能」发生改变时才触发脏检查。解决这个问题有很多很聪明的技巧，有些框架已经在使用了。但是否会有完美的方案还不好说。</p>
<p>Web的生态系统应该有更多的能力去创新和改进它的声明机制，比如：</p>
<ul>
<li>约束型模型系统</li>
<li>自动持久化系统（比如把变化数据保存在IndexedDB或LocalStorage中）</li>
<li>容器对象（Ember，Backbone）</li>
</ul>
<p><a href="http://www.slideshare.net/mixonic/containers-di" target="_blank" rel="external">容器</a>对象是一些框架用来在内部保存数据的对象。它们有对数据的存取方法，这样它们就可以在你访问或者获取数据时，捕获到这一行为，然后在内部进行广播。它工作得很好。这套机制拥有相对不错的性能，以及良好的算法。下面举一个使用Ember容器对象的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 容器对象</span></div><div class="line">MyApp.president = Ember.Object.create({</div><div class="line">  name: <span class="string">"Barack Obama"</span></div><div class="line">});</div><div class="line"> </div><div class="line">MyApp.country = Ember.Object.create({</div><div class="line">  <span class="comment">// 以「Binding」结尾的属性名是告诉Ember创建一个绑定属性，绑定到persidentName属性。</span></div><div class="line">  presidentNameBinding: <span class="string">"MyApp.president.name"</span></div><div class="line">});</div><div class="line"> </div><div class="line"><span class="comment">// 在Ember处理完绑定后：</span></div><div class="line">MyApp.country.get(<span class="string">"presidentName"</span>);</div><div class="line"><span class="comment">// "Barack Obama"</span></div><div class="line"></div><div class="line"><span class="comment">// 从服务器获取的数据需要进行转换</span></div><div class="line"><span class="comment">// 与现有的代码结合起来非常困难</span></div></pre></td></tr></table></figure>


<p>发现改变的开销与发生改变的对象的数量是成正比的。另一个问题是你现在正在使用一个不同类型的对象。总的来说你需要将从服务器获取到的数据转换为这类对象以便他们能够进行监视。</p>
<p>对于现有的代码这种方式不能很好地进行整合，因为现有代码大部分都假设操作的是原生数据，而非这些特殊类型的对象。</p>
<h2 id="隆重推出Object-observe()">隆重推出Object.observe()</h2>
<p>理想情况下，我们想要的是兼顾了双方优点的东西——一种能够监听原生数据对象（常规JavaScript对象）的方法，并且，不需要总是进行脏检查。它拥有良好的算法，并且能够很好地整合到平台中。这些都是<code>Object.observe()</code>将带给我们的。</p>
<p>它允许我们监视一个对象，改变其属性，然后得到发生了什么变动。原理就说到这里，让我们看看代码！</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_3.png" alt="enter image description here"></p>
<h2 id="Object-observe()_and_Object-unobserve()">Object.observe() and Object.unobserve()</h2>
<p>我们来想象一下，这里有一个简单、原生的JavaScript对象来代表一个模型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数据模型可以是一个简单的原生对象</span></div><div class="line"><span class="keyword">var</span> todoModel = {</div><div class="line">  label: <span class="string">'Default'</span>,</div><div class="line">  completed: <span class="literal">false</span></div><div class="line">};</div></pre></td></tr></table></figure>


<p>我们可以指定一个回调函数来处理该对象随时可能发生的改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span><span class="params">(changes)</span></span>{</div><div class="line">  changes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(change, i)</span></span>{</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'what property changed? '</span> + change.name);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'how did it change? '</span> + change.type);</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'whats the current value? '</span> + change.object[change.name]);</div><div class="line">      <span class="built_in">console</span>.log(change); <span class="comment">// 所有变化</span></div><div class="line">  });</div><div class="line">}</div></pre></td></tr></table></figure>



<p>我们可以使用O.o()来监视这些变化，将被监视对象作为第一个参数，将回调函数作为第二个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.observe(todoModel, observer);</div></pre></td></tr></table></figure>


<p>下面我们对Todos做些修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">todoModel.label = <span class="string">'Buy some more milk'</span>;</div></pre></td></tr></table></figure>


<p>看看控制台，我们得到了一些非常有用的信息！我们知道了哪个属性发生了改变，它是怎么改变的，它的新值是什么：</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_4.png" alt="enter image description here"></p>
<p>哇哦！再见吧，脏检查！你的墓碑上应该被刻上「Comic Sans」字体。让我们来改变另一个属性。这回是「completeBy」属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">todoModel.completeBy = <span class="string">'01/01/2014'</span>;</div></pre></td></tr></table></figure>


<p>正如我们所见，又再次成功得到了变化的报告：</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_5.png" alt="enter image description here"></p>
<p>太棒了。要是我们删掉「completed」属性会怎么样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> todoModel.completed;</div></pre></td></tr></table></figure>

<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_6.png" alt="enter image description here"></p>
<p>我们会看到，就像我们想的那样一个包含了本次删除信息的报告被返回，该属性的新值现在是「undefined」。所以，我们现在知道了你可以知道属性何时被添加，何时被删除。基本上，一个对象身上的属性集（”new”、 “deleted”、 “reconfigured”）以及它的原型链（<em>proto</em>）（都可以被我们侦听到）。</p>
<p>任何监视系统都存在一个用于停止监听变化的方法。在这里，它叫「<code>Object.unobserve()</code>」。它与O.o()拥有相同的签名，调用方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.unobserve(todoModel, observer);</div></pre></td></tr></table></figure>



<p>下面我们看到，在执行了这行语句后，模型发生的变化就不再被报告出来了。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_7.png" alt="enter image description here"></p>
<h2 id="指定感兴趣的变化">指定感兴趣的变化</h2>
<p>到现在为止我们已经对如何获取一个被监视对象发生变化的列表有了基础的了解。那么如果你只关心一个对象所有变化的一部分，而非全部，怎么办？每个人都需要垃圾邮件过滤器。监听器可以通过一个「accept list」来指定那些我们真正关心的变化类型。这个列表可以通过O.o()的第三个参数来指定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.observe(obj, callback, optAcceptList)</div></pre></td></tr></table></figure>



<p>让我们来通过一个例子来展示如何使用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 和前面一样，一个简单的数据模型</span></div><div class="line"><span class="keyword">var</span> todoModel = {</div><div class="line">  label: <span class="string">'Default'</span>,</div><div class="line">  completed: <span class="literal">false</span></div><div class="line">};</div><div class="line"><span class="comment">// 然后我们指定一个回调函数用来接收产生的任何变化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span><span class="params">(changes)</span></span>{</div><div class="line">  changes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(change, i)</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(change);</div><div class="line">  })</div><div class="line">};</div><div class="line"><span class="comment">// 这回我们监听的时候，指定一个包含我们关心的变更类型的数组</span></div><div class="line"><span class="built_in">Object</span>.observe(todoModel, observer, [<span class="string">'delete'</span>]);</div><div class="line"><span class="comment">// 不填写第三个参数，其默认值为固有类型</span></div><div class="line">todoModel.label = <span class="string">'Buy some milk'</span>;</div><div class="line"><span class="comment">// 注意这里没有任何变更被报告出来</span></div></pre></td></tr></table></figure>


<p>理所当然的，当我们删除「label」属性时，这个类型的变化就被监听到了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> todoModel.label;</div></pre></td></tr></table></figure>


<p>如果你不指定这个「accept list」，它将默认监听固有类型（”add”，”update”，”delete”，”reconfigure”，”preventExtensions”（因为不可扩展对象的对象不能被监听））。</p>
<h2 id="通知">通知</h2>
<p>O.o()也有通知的概念。它们一点都不像手机上那些气人的玩意儿，但相当有用。通知与「<a href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver" target="_blank" rel="external">Mutation Observers</a>」类似。它们在微任务的结束时发生。在浏览器环境中，这几乎就是当前事件处理器的结束的时候。</p>
<p>这个时间点非常好，因为这时一般正是一个工作单元刚刚完成，这样监听器就可以开始它的工作了。这是一个很好的回合制处理模型。</p>
<p>一个使用了通知器的工作流有点像下图所示：</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_8.png" alt=""></p>
<p>让我们来看个例子，当一个对象的属性发生get或set操作时，应该怎样使用通知器来自定义通知。注意看代码注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个简单模型</span></div><div class="line"><span class="keyword">var</span> model = {</div><div class="line">    a: {}</div><div class="line">};</div><div class="line"><span class="comment">// 一个独立变量，一会儿用于模型的getter方法</span></div><div class="line"><span class="keyword">var</span> _b = <span class="number">2</span>;</div><div class="line"><span class="comment">// 给「a」定义一个新属性「b」，并为「b」指定自定义的getter和setter</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(model.a, <span class="string">'b'</span>, {</div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">return</span> _b;</div><div class="line">    },</div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="params">(b)</span> </span>{</div><div class="line">        <span class="comment">// 一旦对「b」进行赋值，就会发出一个指定变化类型的通知。</span></div><div class="line">        <span class="comment">// 这给了你很大的空间控制通知。</span></div><div class="line">        <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>).notify({</div><div class="line">            type: <span class="string">'update'</span>,</div><div class="line">            name: <span class="string">'b'</span>,</div><div class="line">            oldValue: _b</div><div class="line">        });</div><div class="line">        <span class="comment">// 将新的值在控制台中输出</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>, b);</div><div class="line">        _b = b;</div><div class="line">    }</div><div class="line">});</div><div class="line"><span class="comment">// 设置我们的监听器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span><span class="params">(changes)</span> </span>{</div><div class="line">    changes.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(change, i)</span> </span>{</div><div class="line">        <span class="built_in">console</span>.log(change);</div><div class="line">    })</div><div class="line">}</div><div class="line"><span class="comment">// 开始监听model.a</span></div><div class="line"><span class="built_in">Object</span>.observe(model.a, observer);</div></pre></td></tr></table></figure>

<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_9.png" alt=""></p>
<p>当属性值变化（「update」）时我们得到了报告。而其他的，视对象的实现选择报告（<code>notifier.notifyChange()</code>）。</p>
<p>多年的Web开发经验告诉我们你会最先尝试同步过程，因为这对你的思维最简单。问题是他创造了一个从根本上很危险的处理模型。假设你在编写代码，然后说，更新这个模型的属性，你其实并不希望更新属性的过程引入一些代码，这些代码还能做任何它们想做的事。你运行一个函数时，过程和你想的一点都不一样，这肯定不理想。</p>
<p>如果你是一个观察器，你肯定不想在一些变化还在进行时就被调用。也不想在变化还没有发生完全的非稳定情况下被叫去执行。这样只会得到错误的检测结果。如果需要经常忍受这样的不确定因素，一般来说，这是一个不怎么好用的模型。异步稍微难处理些，却是一种可以让你愉快结束一天工作的模型。</p>
<p>这个问题的解决方案就是「综合变更记录」（synthetic change records）。</p>
<h2 id="Synthetic_change_records">Synthetic change records</h2>
<p>基本来说，如果你想要拥有存取器或计算属性（译者注：Ember里有这个概念，英文原文为Computed Properties），那么当数值发生改变时进行通知就是你的责任。这会带来一些额外的工作，但它被设计为这个机制的一种一级特性，这类通知会与来自底层数据对象、属性的其他通知会被一起发出来。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_10.png" alt=""></p>
<p>监视存取器和计算属性的问题可以通过「notifier.notiffy」解决——这也是O.o()的另一部分。大部分的监视系统都想要以某些手段发布新的值。有很多方法可以处理这个工作，O.o()不关注哪种方式才是「正确的」。计算属性应该是个存取器，当其内部状态（私有的）发生改变时进行通知。</p>
<p>还是那句话，Web开发者应该期待出现一些库，更方便地实现通知与计算属性（并减少样板代码）。</p>
<p>让我们来看下一个例子，这有个Circle类。这个Circle类有个半径属性。这次的例子中，半径是一个存取器，当数值发生改变时，它会自己通知自己。这个通知会连同其他变化通知一起发送给这个对象或其他对象。基本上，如果你想要在一个对象上实现合成属性或计算属性，你必须选择一个能让他们工作的策略。一旦你进行了选择，它将适配你的整个系统。</p>
<p>跳过代码可以看到它在DevTools中的运行结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span><span class="params">(r)</span> </span>{</div><div class="line"> <span class="keyword">var</span> radius = r;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">notifyAreaAndRadius</span><span class="params">(radius)</span> </span>{</div><div class="line">   notifier.notify({</div><div class="line">     type: <span class="string">'update'</span>,</div><div class="line">     name: <span class="string">'radius'</span>,</div><div class="line">     oldValue: radius</div><div class="line">   })</div><div class="line">   notifier.notify({</div><div class="line">     type: <span class="string">'update'</span>,</div><div class="line">     name: <span class="string">'area'</span>,</div><div class="line">     oldValue: <span class="built_in">Math</span>.pow(radius * <span class="built_in">Math</span>.PI, <span class="number">2</span>)</div><div class="line">   });</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'radius'</span>, {</div><div class="line">   get: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">return</span> radius;</div><div class="line">   },</div><div class="line">   set: <span class="function"><span class="keyword">function</span><span class="params">(r)</span> </span>{</div><div class="line">     <span class="keyword">if</span> (radius === r)</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">     notifyAreaAndRadius(radius);</div><div class="line">     radius = r;</div><div class="line">   }</div><div class="line"> });</div><div class="line"></div><div class="line"> <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'area'</span>, {</div><div class="line">   get: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">return</span> <span class="built_in">Math</span>.pow(radius, <span class="number">2</span>) * <span class="built_in">Math</span>.PI;</div><div class="line">   },</div><div class="line">   set: <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>{</div><div class="line">     r = <span class="built_in">Math</span>.sqrt(a/<span class="built_in">Math</span>.PI);</div><div class="line">     notifyAreaAndRadius(radius);</div><div class="line">     radius = r;</div><div class="line">   }</div><div class="line"> });</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span><span class="params">(changes)</span></span>{</div><div class="line"> changes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(change, i)</span></span>{</div><div class="line">   <span class="built_in">console</span>.log(change);</div><div class="line"> })</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_11.png" alt=""></p>
<h2 id="存取器属性">存取器属性</h2>
<p>这里对存取器属性进行一下快速说明。前面我们提到对于数据属性只有当值改变时才能够被监听到，但这不包括计算属性或存取器属性。原因是JavaScript没有存取器属性值变化的概念。存取器只是一组函数而已。</p>
<p>如果给一个存取器赋值，那么JavaScript只是调用了这个方法，从它的视角来看什么变化也没有发生。他只是给了一段代码一次运行的机会。</p>
<p>从上面给半径赋值为5的例子上，这个问题从语义上就很好理解了。我们应该能够知道到底发生了什么。这个确实是个未解决的问题。这个例子演示了为什么。任何一个系统都没有什么方法知道存取器方法的意图是什么，因为里面可以随便写任何代码。在这里可以做任何你想做的事。每次访问都会更新数值，因此询问它是否发生了改变没有太大的意义。</p>
<h2 id="使用一个回调监听多个对象">使用一个回调监听多个对象</h2>
<p>O.o()的另一个可能的模式是单回调监听器概念。它允许一个回调函数用来监听许多不同的对象。这个回调函数会在「微任务结束」（注意其与Mutation Observers的相似性）时接收到所有对象变化的完整集合。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_12.png" alt=""></p>
<h3 id="大规模变化">大规模变化</h3>
<p>也许你正在开发一个非常非常庞大的应用，经常会发生规模庞大的变化。我们会希望对象能够以一种更紧凑的方式（用于替代广播一大堆属性变化的方式）来描述大量属性被改变的大型语义变化。</p>
<p>O.o()通过两个特别的实用工具来帮助我们解决这个问题：<code>notiier.performChange()</code>和<code>notifier.notify()</code>，后者我们已经介绍过了。</p>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_13.png" alt=""></p>
<p>让我们通过一个例子，来看如何描述一个大规模变化。这里我们定义了一个「Thingy」对象，它包含了一些工具方法（multiply，increment，incrementAndMultiply）。一旦一个工具方法被调用，它将告知系统一大堆事情组合成了一个特殊类型的变化。</p>
<p>举个例子：<code>notifier.performChange(“foo”, performFooChangeFn);</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thingy</span><span class="params">(a, b, c)</span> </span>{</div><div class="line"> <span class="keyword">this</span>.a = a;</div><div class="line"> <span class="keyword">this</span>.b = b;</div><div class="line">}</div><div class="line"></div><div class="line">Thingy.MULTIPLY = <span class="string">'multiply'</span>;</div><div class="line">Thingy.INCREMENT = <span class="string">'increment'</span>;</div><div class="line">Thingy.INCREMENT_AND_MULTIPLY = <span class="string">'incrementAndMultiply'</span>;</div><div class="line"></div><div class="line"></div><div class="line">Thingy.prototype = {</div><div class="line"> increment: <span class="function"><span class="keyword">function</span><span class="params">(amount)</span> </span>{</div><div class="line">   <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 告知系统一组结果组合成了一个特殊类型的变化</span></div><div class="line">   <span class="comment">// notifier.performChange('foo', performFooChangeFn);</span></div><div class="line">   <span class="comment">// notifier.notify('foo', 'fooChangeRecord');</span></div><div class="line">   notifier.performChange(Thingy.INCREMENT, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">this</span>.a += amount;</div><div class="line">     <span class="keyword">this</span>.b += amount;</div><div class="line">   }, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">   notifier.notify({</div><div class="line">     object: <span class="keyword">this</span>,</div><div class="line">     type: Thingy.INCREMENT,</div><div class="line">     incremented: amount</div><div class="line">   });</div><div class="line"> },</div><div class="line"></div><div class="line"> multiply: <span class="function"><span class="keyword">function</span><span class="params">(amount)</span> </span>{</div><div class="line">   <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">   notifier.performChange(Thingy.MULTIPLY, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">this</span>.a *= amount;</div><div class="line">     <span class="keyword">this</span>.b *= amount;</div><div class="line">   }, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">   notifier.notify({</div><div class="line">     object: <span class="keyword">this</span>,</div><div class="line">     type: Thingy.MULTIPLY,</div><div class="line">     multiplied: amount</div><div class="line">   });</div><div class="line"> },</div><div class="line"></div><div class="line"> incrementAndMultiply: <span class="function"><span class="keyword">function</span><span class="params">(incAmount, multAmount)</span> </span>{</div><div class="line">   <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">   notifier.performChange(Thingy.INCREMENT_AND_MULTIPLY, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">this</span>.increment(incAmount);</div><div class="line">     <span class="keyword">this</span>.multiply(multAmount);</div><div class="line">   }, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">   notifier.notify({</div><div class="line">     object: <span class="keyword">this</span>,</div><div class="line">     type: Thingy.INCREMENT_AND_MULTIPLY,</div><div class="line">     incremented: incAmount,</div><div class="line">     multiplied: multAmount</div><div class="line">   });</div><div class="line"> }</div><div class="line">}</div></pre></td></tr></table></figure>


<p>然后，我们定义了两个监听器来监听这个对象：一个用来捕获所有的变化，另一个用来捕获我们定义的特殊类型的变化（Thingy.INCREMENT，ThingyMULTIPLY，Thingy.INCREMENT_AND_MULTIPLY）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> observer, observer2 = {</div><div class="line">   records: <span class="literal">undefined</span>,</div><div class="line">   callbackCount: <span class="number">0</span>,</div><div class="line">   reset: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">     <span class="keyword">this</span>.records = <span class="literal">undefined</span>;</div><div class="line">     <span class="keyword">this</span>.callbackCount = <span class="number">0</span>;</div><div class="line">   },</div><div class="line">};</div><div class="line"></div><div class="line">observer.callback = <span class="function"><span class="keyword">function</span><span class="params">(r)</span> </span>{</div><div class="line">   <span class="built_in">console</span>.log(r);</div><div class="line">   observer.records = r;</div><div class="line">   observer.callbackCount++;</div><div class="line">};</div><div class="line"></div><div class="line">observer2.callback = <span class="function"><span class="keyword">function</span><span class="params">(r)</span></span>{</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Observer 2'</span>, r);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">Thingy.observe = <span class="function"><span class="keyword">function</span><span class="params">(thingy, callback)</span> </span>{</div><div class="line"> <span class="comment">// Object.observe(obj, callback, optAcceptList)</span></div><div class="line"> <span class="built_in">Object</span>.observe(thingy, callback, [Thingy.INCREMENT,</div><div class="line">                                   Thingy.MULTIPLY,</div><div class="line">                                   Thingy.INCREMENT_AND_MULTIPLY,</div><div class="line">                                   <span class="string">'update'</span>]);</div><div class="line">}</div><div class="line"></div><div class="line">Thingy.unobserve = <span class="function"><span class="keyword">function</span><span class="params">(thingy, callback)</span> </span>{</div><div class="line"> <span class="built_in">Object</span>.unobserve(thingy);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们可以和这个对象愉快的玩耍了。让我们来定义一个新的Thingy对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> thingy = <span class="keyword">new</span> Thingy(<span class="number">2</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>


<p>监听他，并且给它鼓捣点变化出来。天呐，太好玩了。好多小玩意儿！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听thingy</span></div><div class="line"><span class="built_in">Object</span>.observe(thingy, observer.callback);</div><div class="line">Thingy.observe(thingy, observer2.callback);</div><div class="line"></div><div class="line"><span class="comment">// 调用thingy暴露的方法</span></div><div class="line">thingy.increment(<span class="number">3</span>);               <span class="comment">// { a: 5, b: 7 }</span></div><div class="line">thingy.b++;                        <span class="comment">// { a: 5, b: 8 }</span></div><div class="line">thingy.multiply(<span class="number">2</span>);                <span class="comment">// { a: 10, b: 16 }</span></div><div class="line">thingy.a++;                        <span class="comment">// { a: 11, b: 16 }</span></div><div class="line">thingy.incrementAndMultiply(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// { a: 26, b: 36 }</span></div></pre></td></tr></table></figure>

<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_14.png" alt=""></p>
<p>所有在「perform function」里被执行的内容都被认为是「大规模的变更」。接收「大规模变更」的监听器只能接收到「大规模变更」的记录。一般监听器是无法接收到通过「perform function」造成的底层变化的。 </p>
<h2 id="监听数组">监听数组</h2>
<p>我们说了半天如何监听一个对象的变化，那数组呢？！好问题。当有人告诉我「好问题」时，我从来没有去听他们的答案，因为我正忙于夸奖自己问了一个这么好的问题。好吧，我离题了。我们也有个新方法给数组使用！</p>
<p><code>Array.observe()</code>是用于处理自身的大规模变化的方法。举个例子：splice，unshift或任何隐式地改变了数组的长度的行为——就像「splice」这样，他内部调用了<code>notifier.performChange(“splice”, …)</code>。</p>
<p>下面看个例子，这里我们监听了一个数组模型。并且当有任何底层数据的改变发生时我们会得到一个变化列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> model = [<span class="string">'Buy some milk'</span>, <span class="string">'Learn to code'</span>, <span class="string">'Wear some plaid'</span>];</div><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.observe(model, <span class="function"><span class="keyword">function</span><span class="params">(changeRecords)</span> </span>{</div><div class="line"> count++;</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'Array observe'</span>, changeRecords, count);</div><div class="line">});</div><div class="line"></div><div class="line">model[<span class="number">0</span>] = <span class="string">'Teach Paul Lewis to code'</span>;</div><div class="line">model[<span class="number">1</span>] = <span class="string">'Channel your inner Paul Irish'</span>;</div></pre></td></tr></table></figure>

<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_15.png" alt=""></p>
<h2 id="性能">性能</h2>
<p>考虑O.o()对计算性能的影响时，可以把它想作一种读取缓存。大致来说，当如下情况时缓存是非常好的选择（按重要程度排序）：</p>
<ol>
<li>读取频率远大于写入频率。</li>
<li>能够创建缓存，通过增加常数时间复杂度的写入步骤换取读取时的算法性能提升。</li>
<li>写入时的固定延迟是可接受的。</li>
</ol>
<p>O.o()被设计用于第一种情况。</p>
<p>脏检查需要保留一份你正在监听的数据的完整备份。这就意味着使用脏检查需要更多的内存，而使用O.o()是不需要的。脏检查，尽管是个还不错的过渡方案，从根本是个泄露的抽象（译者注：原文为「leaky abstraction」，直译为抽象泄露，由Joel Spolsky在其Blog中提出，指任何试图减少或隐藏复杂性的抽象，其实并不能完全屏蔽细节，试图被隐藏的复杂细节总是可能会泄漏出来），会带来不必要的复杂性。</p>
<p>为什么？每当数据「可能」发生变化时，脏检查就必须执行。这没有什么特别好的方法能够解决这个问题，并且每种方案都有明显的缺点（举例来说，轮询就需要承担视觉效果上以及竞争条件上的风险）。脏检查还需要注册一个全局的监听器，其会产生内存泄露的风险，增加析构成本，这都是O.o()可以避免的。</p>
<p>让我们来看一些数据。</p>
<p>下面一组benchmark测试（可在<a href="https://github.com/Polymer/observe-js/tree/master/benchmark" target="_blank" rel="external">GitHub</a>上看到）对脏检查和O.o()进行了对比。以图表的方式对比了不同监听对象集合数和变更数时的性能水平。</p>
<p>总体结果上看，脏检查的性能与监听对象的数量成正比，而O.o()的性能与我们制造的变更数量成正比。</p>
<h3 id="脏检查-1">脏检查</h3>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_16.png" alt=""></p>
<h3 id="在Chrome上使用Object-observe()">在Chrome上使用Object.observe()</h3>
<p><img src="/jsbear/asset/posts/2014-12-08-observe/image_17.png" alt=""></p>
<h2 id="Object-observe()的Polyfill">Object.observe()的Polyfill</h2>
<p>很高兴O.o()已经可以在Chrome 36中使用了，但是在其它浏览器又如何呢？放心吧。Polymer的<a href="https://github.com/Polymer/observe-js" target="_blank" rel="external">Observe-JS</a>是一个O.o()的polyfill，如果浏览器存在原生O.o()实现那么会直接使用它，否则就会使用其polyfill实现并且顺带提供了一些有用的语法糖。它创造了一个紧凑的世界，在里面整合了所有变更并且分发出去。。它提供了两个特别强大的东西：</p>
<p>1）你可以监听一个路径。意思就是你可以说，我要监听一个对象的「foo.bar.baz」，然后它就会在这个路径的值发生改变时告知你。如果这个路径不可达，它会认为这个值为undefined。</p>
<p>举例监听一个对象路径的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = { foo: { bar: <span class="string">'baz'</span> } };</div><div class="line"></div><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> PathObserver(obj, <span class="string">'foo.bar'</span>);</div><div class="line">observer.open(<span class="function"><span class="keyword">function</span><span class="params">(newValue, oldValue)</span> </span>{</div><div class="line"> <span class="comment">// 报告obj.foo.bar变更后的值</span></div><div class="line">});</div></pre></td></tr></table></figure>


<p>2）数组发生拼接时会告知你。从一个数据得到另一个新数据时，数组拼接是这个过程中最小的操作单位。这是一种转换或数组的不同视图。它是你将旧状态迁移到新状态所做的工作的最小量。</p>
<p>举例报告一个数组的变化，以最小拼接集合的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> ArrayObserver(arr);</div><div class="line">observer.open(<span class="function"><span class="keyword">function</span><span class="params">(splices)</span> </span>{</div><div class="line"> <span class="comment">// arr中的元素发生改变时响应</span></div><div class="line"> splices.forEach(<span class="function"><span class="keyword">function</span><span class="params">(splice)</span> </span>{</div><div class="line">   splice.index; <span class="comment">// 发生改变位置的索引值</span></div><div class="line">   splice.removed; <span class="comment">// 被移除的元素，类型为数组</span></div><div class="line">   splice.addedCount; <span class="comment">// 添加元素的数量</span></div><div class="line"> });</div><div class="line">});</div></pre></td></tr></table></figure>


<h2 id="框架和Object-observe()">框架和Object.observe()</h2>
<p>就像我们前面说的，在那些支持此特性的浏览器中，O.o()给了那些框架和库巨大的机会去改善他们数据绑定的性能。</p>
<p>来自Ember的Yehuda Katz和Erik Bryn已经确认将在Ember近期的开发计划中添加O.o的支持。Angular的Misko Hervy写了一个<a href="https://docs.google.com/document/d/10W46qDNO8Dl0Uye3QX0oUDPYAwaPl0qNy73TVLjd1WI/edit" target="_blank" rel="external">设计文档</a>指出Angular2.0将改进变更探测的实现。他们的长期计划是当Object.observe()在Chrome稳定版落地后再使用，在这之前先使用他们自己的<a href="https://github.com/angular/watchtower.js/" target="_blank" rel="external">Watchtower.js</a>作为变更探测方案。超~~期待。</p>
<h2 id="结论">结论</h2>
<p>O.o()是现在Web平台上你已经可以使用的一项强大的新机能。</p>
<p>我们希望它能赶快在更多的浏览器中落地。使JavaScript框架能够提升访问原生对象监听的性能。以Chrome为目标浏览器开发的话，O.o已经在Chrome 36（及以上）可以使用了，并且不久后的Opera版本也会添加这个特性。</p>
<p>因此，把它用起来吧，并且将<code>Object.observe()</code>介绍给其他的JavaScript框架的作者，告诉他们可以如何提升你的应用中数据绑定的性能的。那绝对令人兴奋的时代就在前方！</p>
<h2 id="资料">资料</h2>
<ul>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe" target="_blank" rel="external">Object.observe() on the Harmony wiki</a></li>
<li><a href="http://bocoup.com/weblog/javascript-object-observe/" target="_blank" rel="external">Databinding with Object.observe() by Rick Waldron</a></li>
<li><a href="http://addyosmani.com/blog/the-future-of-data-binding-is-object-observe/" target="_blank" rel="external">Everything you wanted to know about Object.observe() - JSConf</a></li>
<li><a href="http://georgestefanis.com/blog/2014/03/25/object-observe-ES7.html" target="_blank" rel="external">Why Object.observe() is the best ES7 feature</a><br><em>感谢Rafael Weinstein，Jake Archibald，Eric Bidelman，Paul Kinlan和Vivian Cromwell提供建议，进行检阅。</em></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：Addy Osmani</p>
<p>发布日期： 2014年5月20日</p>
<p>更新： 2014年5月20日</p>
<p>翻译：刘凯</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jsbear.baidu.com/tags/JavaScript/"/>
    
      <category term="ES7" scheme="http://jsbear.baidu.com/tags/ES7/"/>
    
      <category term="译文" scheme="http://jsbear.baidu.com/categories/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的基准测试]]></title>
    <link href="http://jsbear.baidu.com/2014/11/27/javascript-benchmarking/"/>
    <id>http://jsbear.baidu.com/2014/11/27/javascript-benchmarking/</id>
    <published>2014-11-27T10:22:07.000Z</published>
    <updated>2015-01-25T13:09:40.586Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>审阅校对：李叶，刘凯</p>
<p>原文：<a href="https://mathiasbynens.be/notes/javascript-benchmarking" target="_blank" rel="external">Bulletproof JavaScript benchmarks</a></p>
</blockquote>
<p>做JavaScript的基准测试并没有想的那么简单。即使不考虑浏览器差异所带来的影响，也还有很多坑——甚至陷阱——要注意。</p>
<a id="more"></a>

<p>这是我创建了<a href="http://jsperf.com/" target="_blank" rel="external">jsPerf</a>的一个原因，一个你可以轻松创建并分享各种代码片段对比结果的简单工具。用起来非常省事，只需把想要测试的代码录入然后jsPerf会为你创建好可以跨平台跑起来的测试用例。</p>
<p>内部实现上，最开始jsPerf用的是一个基于<a href="http://www.broofa.com/Tools/JSLitmus/" target="_blank" rel="external">JSLitmus</a>的基准测试库，我将它称作<a href="http://benchmarkjs.com/" target="_blank" rel="external">Benchmark.js</a>。后续又往里面添加了更多的特性，最近，<a href="http://allyoucanleet.com/" target="_blank" rel="external">John-David Dalton</a>干脆将这个库彻底重写了一遍。所以现在Benchmark.js已经比之前好很多了。</p>
<p>本文对JavaScript基准测试的编写和运行有一定的参考意义。</p>
<h2 id="基准测试的类型">基准测试的类型</h2>
<p>有很多方法可以测试一段JavaScript代码的性能。最常见的做法是类似下面这样的：</p>
<h3 id="方案A">方案A</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> totalTime,</div><div class="line">    start = <span class="keyword">new</span> <span class="built_in">Date</span>,</div><div class="line">    iterations = <span class="number">6</span>;</div><div class="line"><span class="keyword">while</span> (iterations--) {</div><div class="line">  <span class="comment">// 被测试的代码</span></div><div class="line">}</div><div class="line"><span class="comment">// totalTime → 运行该测试代码6次需要的时间（单位：毫秒）</span></div><div class="line">totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div></pre></td></tr></table></figure>

<p>这种方案将被测试的代码循环执行多次直到预设值（本例为6次）。最后用结束时的时间减去开始的时间，得到运行的总时间。</p>
<p> 方案A被用于<a href="https://github.com/kamicane/slickspeed/" target="_blank" rel="external">SlickSpeed</a>, <a href="https://github.com/phiggins42/taskspeed" target="_blank" rel="external">Taskspeed</a>, <a href="http://www2.webkit.org/perf/sunspider/sunspider.html" target="_blank" rel="external">SunSpider</a>, 和 <a href="http://krakenbenchmark.mozilla.org/" target="_blank" rel="external">Kraken</a>这些流行的基准测试库中。</p>
<h4 id="缺憾">缺憾</h4>
<p> 鉴于现在的设备和浏览器运行得越来越快，这种将代码运行固定次数的测试方法有越来越大的概率会得到一个0ms的时间差结果，显然这样的结果是毫无意义的。</p>
<h3 id="方案B">方案B</h3>
<p>另一种方案是计算固定时间内进行了多少运算量。较之前的做法，这回你不用指定一个固定的循环次数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hz,</div><div class="line">    period,</div><div class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>,</div><div class="line">    runs = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span> {</div><div class="line">  <span class="comment">// 被测试的代码</span></div><div class="line">  runs++;</div><div class="line">  totalTime = <span class="keyword">new</span> <span class="built_in">Date</span> - startTime;</div><div class="line">} <span class="keyword">while</span> (totalTime &lt; <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将毫秒转为秒</span></div><div class="line">totalTime /= <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="comment">// period → 单位运算的耗时</span></div><div class="line">period = totalTime / runs;</div><div class="line"></div><div class="line"><span class="comment">// hz → 单位时间（1秒）内进行的运算量</span></div><div class="line">hz = <span class="number">1</span> / period;</div><div class="line"></div><div class="line"><span class="comment">// 上面两步可以简写如下：</span></div><div class="line"><span class="comment">// hz = (runs * 1000) / totalTime;</span></div></pre></td></tr></table></figure>

<p>将测试代码一直循环运行直到总耗时<code>totalTime</code>大于等于1000毫秒，也就是1秒种。</p>
<p>方案B 用于<a href="http://dromaeo.com/" target="_blank" rel="external">Dromaeo</a>和<a href="http://code.google.com/apis/v8/benchmarks.html" target="_blank" rel="external">V8 Benchmark Suite</a>这两个库。</p>
<h4 id="不足">不足</h4>
<p>由于有垃圾回收、（运行时的）引擎对代码的动态优化以及其他进程等的影响，此方案在重复进行测试时得到的结果不尽相同。为了得到更精确的测试结果，需要多次测试取均值。而上面提到的V8库只会对测试运行一次，Dromaeo则会运行5次，但其实还可以做得更彻底以获取更加精准的结果。一个可行的途径就是想办法将目前的测试时间由1000毫秒压缩到50毫秒，当然前提是系统提供给我们一个绝对精确的时钟，这能保证时间尽可能多地用于运行测试代码（而不会过多地被操作系统的中间停顿浪费掉）。</p>
<h3 id="方案C">方案C</h3>
<p>JSLitmus 这个库结合了前面两种方案的优点。采用方案A 来将测试代码运行<code>n</code>次，同时动态调整这个<code>n</code>值以保证测试能够进行到一个最小的时长，也就是方案B所描述的那样。</p>
<h4 id="症结">症结</h4>
<p>JSLitmus 规避了方案A的缺点但同时引入了方案B的不足之处。为了进一步提高测试的准确率，JSLitmus 将结果进行了较准，取出3次空测试（译注：方案 B 的问题在于有很多跑非测试代码的开销，这里通过跑空测试得到这部分时间从结果中移除 ）中运行最快的一次，再将每次基准测试的结果减去这个最快值。不幸的是这种做法为了规避B方案的毛病（译注：B方案需要运行多次以得到更多采样集合以取均值，换句话说要得到越准确的结果就要耗费越多的时间）反而使结果更不可靠了，因为取3次中最快的一次本身就不符合统计规律。尽管JSLitmus可以多次运行这样的基准测试，将较准后的均值与每次测试结果的均值进行差额运算，但这样得到的最终结果其身上的误差已经足够掩盖之前我们为了提高准确率而做的任何努力了。</p>
<h3 id="方案D">方案D</h3>
<p>前面三种方案的短肋可以通过方法转编（<code>function compilation</code> 编译转化之意，区别于传统编译）和循环展开(loop unrolling)来避免。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>{</div><div class="line">  x == y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">while</span> (iterations--) {</div><div class="line">  test();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// …将会编译转化为 →</span></div><div class="line"><span class="keyword">var</span> hz,</div><div class="line">    startTime = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line"></div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line">x == y;</div><div class="line"><span class="comment">// …</span></div><div class="line"></div><div class="line">hz = (runs * <span class="number">1000</span>) / (<span class="keyword">new</span> <span class="built_in">Date</span> - startTime);</div></pre></td></tr></table></figure>

<p>这种做法将测试代码<a href="http://en.wikipedia.org/wiki/Loop_unwinding" target="_blank" rel="external">变成了展开的形式</a>，避免了循环和较准工作(译注：没有了循环也就无需统计单位时间内的运算量了)。</p>
<h4 id="问题">问题</h4>
<p>然而，它还是有不足之处的。将函数转编会消耗大量内存同时也把CPU拖慢。当你把一个测试跑上几百万次时，可以想象到会创建大量的字符串和转编无数的函数。</p>
<p>这还不算，因为一个函数完全有可能在遇到<code>return</code>后提前结束执行。所以如果测试中函数在第3行就返回了，将循环展开成上百万的代码就显得毫无意义。看来检测这些可能的提前退出还是很有必要的，然后回归到使用<code>while</code>语句（也就是方案A的做法）加上对循环结果的较准。</p>
<h3 id="函数体的提取">函数体的提取</h3>
<p>在Benchmark.js的实现中，使用了一个稍微不同的做法。你可以认为它结合了方案A,B,C还有D的长处。考虑到内存因素，我们没有将循环展开。为了控制住增大结果误差的因素，同时又让测试代码可以使用较为自然的实现和变量，我们将每个测试代码的函数体提取出来。譬如，当用下面的代码进行测试时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="string">'1'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>{</div><div class="line">  x == y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">while</span> (iterations--) {</div><div class="line">  test();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// …转会转编为 →</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>,</div><div class="line">    y = <span class="string">'1'</span>;</div><div class="line"><span class="keyword">while</span> (iterations--) {</div><div class="line">  x == y;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如此一来，Benchmark.js 使用一个与 JSLitmus近似的技术：将提取出来的函数体放到一个循环中（这是方案A的做法），重复执行直到达到一个最小的时限（这是方案B），最后重复整个流程得到有统计学意义的结果。</p>
<h2 id="注意事项">注意事项</h2>
<h3 id="有偏差的毫秒时钟">有偏差的毫秒时钟</h3>
<p>某些浏览器与操作系统的组合中，由于<a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463347.aspx" target="_blank" rel="external">种种</a><a href="http://alivebutsleepy.srnet.cz/unreliable-system-nanotime/" target="_blank" rel="external">因素</a>存在时钟不准的情况。</p>
<p>例如：</p>
<blockquote>
<p>Windows XP开机后，程序执行的时钟周期为 10毫秒，这在其他操作系统中一般为15毫秒。意思就是每隔10毫秒操作系统会接收到来自硬件（译注：也就是CPU的时钟系统）的一次中断。</p>
</blockquote>
<p>一些很老的浏览器（IE或者火狐2）严重依赖操作系统的时钟，也就是说每次你调用<code>new Date().getTime()</code>，它都直接从系统那里去拿这个时间。很显然，如果内部系统的时间都要间隔10毫秒或者15毫秒才更新一次，那测试结果会受很大影响，准确性大大降低。这个问题是需要解决的。</p>
<p>值得庆幸的是，JavaScript是可以<a href="https://mathiasbynens.be/demo/javascript-timers" target="_blank" rel="external">拿到最小的时间度量单位</a>的。这之后，我们可以通过<a href="http://spiff.rit.edu/classes/phys273/uncert/uncert.html" target="_blank" rel="external">数学方式</a>将测试结果的不确定性降低到只有1%。为此，我们将这个最小时间度量单位除以2以得到这个<em>不准确度</em>。假设我们在XP上用IE6，此种情况下最小的度量单位是15毫秒。这个不确定率就为<code>15ms/2=7.5ms</code>。然后我们想控制结果的误差到1%，于是乎我们将刚才得到的不确定性值除以0.01，就得到了达到测试要求需要的最小测试时限为：<code>7.5/0.01=750ms</code>。</p>
<h3 id="其他时钟">其他时钟</h3>
<p>当启用<code>--enable-benchmarking</code> 标志后，Chrome和Chromium会暴露出一个叫做<code>chrome.Interval</code>的方法，可以用它作为一个高精度的时钟使用。</p>
<p>在编写Benchmark.js库时， John-David Dalton 经过一番折腾后将Java里这个纳秒级的时钟通过一个小的Java applet插件暴露到了JavaScript中。</p>
<p>使用更高精度的时钟可以缩短测试周期，相应地可以跑更多测试样本，从而得到一个误差更小的测试结果。</p>
<h3 id="Firebug_会禁用火狐的_JIT">Firebug 会禁用火狐的 JIT</h3>
<p>启用Firebug会禁用火狐高性能的实时(just-in-time <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="external">JIT</a>)本地代码编译，然后你的代码会跑在普通的JavaScript解释器里面。这将会比原先慢很多。所以在跑基准测试时千万记得关掉Firebug。</p>
<p>其他浏览器的元素审查工具比如WebKit的<code>Web Inspector</code>或者欧朋浏览器的<code>Dragonfly</code>在开启时也有类似问题，尽管相比于上面的情况会小很多。所以在跑测试时最好还是关掉这些，或多或少还是会影响测试结果的。</p>
<h3 id="浏览器缺陷和特性">浏览器缺陷和特性</h3>
<p>内部实现中使用了某些循环机制的基准测试容易受到一些浏览器本身缺陷的影响，比如像最近IE9的<a href="http://www.zdnet.com/blog/bott/ie9-takes-top-benchmark-prize-no-cheating-involved/2671" target="_blank" rel="external">dead-code-removal</a>展示的那样。<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=509069" target="_blank" rel="external">火狐<code>TraceMonkey</code> 引擎</a>的一个bug，还有欧朋11 <a href="http://jsperf.com/jquery-css3-not-vs-not" target="_blank" rel="external">对<code>querySelectorAll</code>结果的缓存</a>都会影响到测试结果。这些都是在进行测试是需要注意的。</p>
<h3 id="统计学的重要性">统计学的重要性</h3>
<p>大多数的基准测试/测试代码给出的结果并且没有严格符合统计学要求。John Resig（译注：jQuery原始作者）在他早前的一篇文章「<a href="http://ejohn.org/blog/javascript-benchmark-quality/" target="_blank" rel="external">JavaScript 基准测试的质量</a>」中有提到。简单来说，就是应该尽量考虑到每个测试结果的误差并去减小它。大样本容量的测试代码运行能起到减少误差的作用。</p>
<h3 id="跨浏览器的测试">跨浏览器的测试</h3>
<p>如果你想在不同浏览器中进行测试且想得到较可靠的结果，一定要在真实的浏览器中测试。不要依赖于IE自带的兼容模式，此模式跟他<a href="http://jsperf.com/join-concat#comments" target="_blank" rel="external">所模拟的版本是存在实质性差异</a>的。</p>
<p>还有就是除了跟大多其他浏览器一样会限制脚本的时间外，IE（8及以下）还限制了代码的指令数不能超过5百万。事实上以现在CPU的吞吐能力，这样的数量级处理起来只是半秒钟的事情。如果你配置确实过硬，跑起来倒也没什么只是IE会给出一个<code>Script Warning</code>的警告，这种情况下你可以通过修改注册表来增大这个数量限制。幸运的是微软还提供了一个<a href="http://go.microsoft.com/?linkid=9729250" target="_blank" rel="external">修复助手的程序</a>，你只需要运行即可，比修改注册表方便多了。更可喜的是，IE9中这个逗逼的限制被移除了。</p>
<h2 id="总结">总结</h2>
<p>无论你只是跑了一些测试，或者写一些用例，抑或正在自己写一个基准测试库，关于JavaScript基准测试的奥义远比你看到得要多（译注：就是水很深，并不是跑个分那么简单）。Benchmark.js和jsPerf<a href="https://github.com/bestiejs/benchmark.js/commits/master" target="_blank" rel="external">每周都有更新</a>，包含bug修复，新功能添加和一些提升准确率的技巧。但愿主流浏览器也能够为此做些努力吧…</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>审阅校对：李叶，刘凯</p>
<p>原文：<a href="https://mathiasbynens.be/notes/javascript-benchmarking" target="_blank" rel="external">Bulletproof JavaScript benchmarks</a></p>
</blockquote>
<p>做JavaScript的基准测试并没有想的那么简单。即使不考虑浏览器差异所带来的影响，也还有很多坑——甚至陷阱——要注意。</p>
]]>
    
    </summary>
    
      <category term="javascript" scheme="http://jsbear.baidu.com/tags/javascript/"/>
    
      <category term="性能" scheme="http://jsbear.baidu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="benchmark" scheme="http://jsbear.baidu.com/tags/benchmark/"/>
    
      <category term="译文" scheme="http://jsbear.baidu.com/categories/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[延迟求值-如何让Lo-Dash再提速x100?]]></title>
    <link href="http://jsbear.baidu.com/2014/11/14/lazy-evaluation/"/>
    <id>http://jsbear.baidu.com/2014/11/14/lazy-evaluation/</id>
    <published>2014-11-14T09:57:03.000Z</published>
    <updated>2015-01-25T13:09:40.585Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>审阅校对：李叶</p>
<p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
<a id="more"></a>

<h2 id="延迟求值">延迟求值</h2>
<p>但似乎我错了-还可以让<code>Lo-Dash</code>有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> len = getLength();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p>
<p>这便是<code>Lo-Dash</code>实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span><span class="params">(x)</span> </span>{</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>{ <span class="keyword">return</span> item.price &lt; x; };</div><div class="line">}</div><div class="line"><span class="keyword">var</span> gems = [</div><div class="line">   { name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> }, { name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> },</div><div class="line">   { name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>}, { name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  },</div><div class="line">   { name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> }, { name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> },</div><div class="line">   { name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> }, { name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> }</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</div></pre></td></tr></table></figure>

<p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p>
<p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"></p>
<p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前面5个我们就能拿到结果了。同样为了得到正确的结果，延迟求值则只处理最少的元素。优化后如下图所示：</p>
<p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/grafika.gif" alt="lo-dash naive"></p>
<p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</div><div class="line"></div><div class="line"><span class="comment">// 取出100个含 `55` 的号码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span><span class="params">(str)</span> </span>{</div><div class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>); </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>这个例子中<code>map</code>和<code>filter</code> 将遍历99999 个元素，但很有可能我们只需处理到1000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p>
<p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/benchmark.jpg" alt="benchmark"></p>
<h2 id="流水线">流水线</h2>
<p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是避免产生中间数组，而是对一个元素一次性进行完所有操作。下面用代码说话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure>

<p>上面看似优雅的写法在原始的<code>Lo-Dash</code>里会转换成下面的样子（直接求值）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp1[i] = func1(source[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp2[i] = func2(temp1[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp3[i] = func3(temp2[i]);</div><div class="line">}</div><div class="line">result = temp3;</div></pre></td></tr></table></figure>

<p>当引入了延迟求值后，代码大致就成这样的了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   result[i] = func3(func2(func1(source[i])));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p>
<h2 id="延迟执行">延迟执行</h2>
<p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显式地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</div><div class="line">                      .pluck(<span class="string">'value'</span>)</div><div class="line">                      .reduce(sum);</div><div class="line"></div><div class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{</div><div class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></div><div class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p>
<h2 id="后记">后记</h2>
<p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，<code>Lo-Dash</code>存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p>
<blockquote>
<p>译注：对于<code>lazy evaluation</code> 与<code>deferred execution</code> 中<code>lazy</code> 与<code>deferred</code> 的区分，在翻译时找不到恰当的区分。前者用主流使用的「延迟」会更易懂，而后者同时也译为「延迟」, 但他们在记性上还是存在一定差别的，具体的讨论可见<a href="https://github.com/tbfe/translation/pull/2#discussion_r20362267" target="_blank" rel="external">这里</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>审阅校对：李叶</p>
<p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p>
<p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p>
</blockquote>
<p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jsbear.baidu.com/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="http://jsbear.baidu.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="译文" scheme="http://jsbear.baidu.com/categories/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://jsbear.baidu.com/2014/10/22/hello-world/"/>
    <id>http://jsbear.baidu.com/2014/10/22/hello-world/</id>
    <published>2014-10-22T14:16:32.000Z</published>
    <updated>2015-01-25T13:09:40.585Z</updated>
    <content type="html"><![CDATA[<p class="text-success">Welcome, dude!</p>

<h2 id="初见/Intro">初见/Intro</h2>
<p><span class="dropcap">这</span>是使用<a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>搭建的静态站点，基于<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a>，内容采用<a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown</a> 撰写。</p>
<p>这里，我们进行知识分享扩散，文档整理存放，项目展示介绍。随着时间的推移，会沉淀更多的内容。</p>
<p>时间就像一坛尘封的酒酿，若干年后，就会发现它的醇香。</p>
<p>这里也是。</p>
<a id="more"></a>

<h2 id="本地运行/Run">本地运行/Run</h2>
<p>下面的步骤可以让你快速安装环境，运行本站点。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  <p>在正式开始前，你需要以下原料：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> </li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
</div>

<h3 id="Fork_项目&amp;_获取源码">Fork 项目&amp; 获取源码</h3>
<p>首先在Github fork本项目,然后将fork的代码克隆到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir jsbear</div><div class="line"><span class="built_in">cd</span> jsbear</div><div class="line">git clone https://github.com/{你的github用户名}/jsbear.git</div></pre></td></tr></table></figure>

<h3 id="安装Hexo">安装Hexo</h3>
<p>本地安装Hexo静态站点生成器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure>

<h3 id="安装依赖包">安装依赖包</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install</div><div class="line"><span class="comment"># 或者</span></div><div class="line">npm i</div></pre></td></tr></table></figure>

<h3 id="启动服务器">启动服务器</h3>
<p>准备好了吗？使用下面的命令，来打开站点吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo server</div><div class="line"><span class="comment"># 或者</span></div><div class="line">hexo s</div></pre></td></tr></table></figure>

<p>服务器启动后，在浏览器地址栏输入<code>localhost</code> 进行访问。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  <ul>
<li>项目配置文件已经默认将端口设置为80，所以无需在<code>localhost</code>后加端口访问了</li>
<li>服务器启动后可以按「Ctrl+C」将其停止</li>
</ul>
</div>

<h2 id="书写/Writing">书写/Writing</h2>
<p>当本地运行起来后，You are ready to go!<br>以下步骤让你学会书写并且时实预览效果。</p>
<h3 id="创建新贴">创建新贴</h3>
<p>使用如下命令创建新贴。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"My New Post"</span> <span class="comment">#这里标题最好用英文</span></div></pre></td></tr></table></figure>

<p>它会在项目的<code>source/_posts/</code> 路径下创建一个时间加文章标题的<code>.md</code> 文件。我在这个文件中书写文章内容。</p>
<h3 id="文章选项">文章选项</h3>
<p>上面方法创建的文件中，头部包含了该篇文章的一些配置信息，所以你看到的应该是下面这个样子：</p>
<figure class="highlight markdown"><figcaption><span>以本文的头部信息作示例</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">title: Hello World  #文章的标题，这里可以换成中文</div><div class="line">toc: true   #是否显示文章目录，即右侧自动高亮的目录树</div><div class="line">dropcap: false  #是否启用drocap，类似报刊杂志首字增大的效果</div><div class="line">date: 2014-10-22 14:16:32   #文章创建的时间，匆改</div><div class="line">author: wayou   #需要显示的作者名，可选</div><div class="line">feature: asset/posts/2014-10-22-hello-world/hexo_logo.png    #显示在首页的文章头图，如果不需要可以去掉此项</div><div class="line">description: 本文纯粹吐槽 #显示在文章顶部的描述，可选</div><div class="line">categories: 文档  #文章分类，可选</div><div class="line">tags:   #文章标签，可选</div><div class="line"><span class="bullet">- </span>hexo</div><div class="line"><span class="header">- markdown</span></div><div class="line">---</div><div class="line"></div><div class="line">这里开始正文</div><div class="line"></div><div class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span>  #在正文中写了此注释，则注释前的内容将作为文章摘要显示在首页</div><div class="line"></div><div class="line">这里继续正文</div></pre></td></tr></table></figure>

<h3 id="句法">句法</h3>
<p>使用Markdown句法，我们可以很方便地写出简单优雅的排版。<br>如果你未曾了解过，让我们一起来简单熟悉一些常用MD句法。如果你已经了解，则路过。</p>
<h4 id="标题">标题</h4>
<p>在MD中，以<code>#</code>号开头来标识这一行是标题，个数对应HTML中<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>，这个很好理解。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  <p>为了不影响左边文章目录，下面的示例省去了一二三四级标题</p>
</div>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="header">##### 五级标题</span></div><div class="line"><span class="header">###### 六级标题</span></div></pre></td></tr></table></figure>

<p>结果：</p>
<h5 id="五级标题">五级标题</h5>
<h6 id="六级标题">六级标题</h6>
<h4 id="链接与图片">链接与图片</h4>
<p>链接与图片是书写丰富文章所必备的元素，下面我们来看看。</p>
<h5 id="链接">链接</h5>
<p>MD中链接句法为方括号包裹链接文字，圆括号包裹链接地址。大家看下面的示例感受下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="link_label">Hi, 约么？</span>](<span class="link_url">http://shurufa.baidu.com/</span>)</div></pre></td></tr></table></figure>

<p>结果：<br><a href="http://shurufa.baidu.com/" target="_blank" rel="external">Hi, 约么？</a></p>
<p><br></p>
<h5 id="图片">图片</h5>
<p>图文并茂的页面让人更能够赏心悦目。所以你应该不会吝啬多放几张图片。</p>
<p>MD中图片的写法与链接极其相似，只是链接前端多了个叹号，仅此而以。</p>
<p>同样，我们看一个示例感受下。</p>
<p>美图将至，屏住呼吸。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="link_label">bigger that bigger</span>](<span class="link_url">/jsbear/asset/posts/2014-10-22-hello-world/hexo_logo.png</span>)</div></pre></td></tr></table></figure>

<p>结果：<br><img src="/jsbear/asset/posts/2014-10-22-hello-world/btb.jpg" alt="bigger that bigger"></p>
<h4 id="强调与斜体">强调与斜体</h4>
<p>关于这两者，我们分别都有两种选择，请看下面的示例。</p>
<h5 id="斜体">斜体</h5>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="emphasis">*single asterisks*</span></div><div class="line"></div><div class="line"><span class="emphasis">_single underscores_</span></div></pre></td></tr></table></figure>

<p>结果：</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<h5 id="强调">强调</h5>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="strong">**double asterisks**</span></div><div class="line"></div><div class="line"><span class="strong">__double underscores__</span></div></pre></td></tr></table></figure>

<p>结果</p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<h4 id="列表">列表</h4>
<p>通过列表表达观点，列举论据，显得思路清晰，表达流畅，更能说服读者。<br>在MD中，列表可以通过如下形式实现。</p>
<h5 id="无序列表">无序列表</h5>
<p>下面是无序列表的示例</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>列表项1</div><div class="line"><span class="bullet">* </span>列表项2</div><div class="line"><span class="bullet">* </span>列表项3</div><div class="line"></div><div class="line"><span class="header">#另一种写法</span></div><div class="line"><span class="bullet">- </span>列表项1</div><div class="line"><span class="bullet">- </span>列表项2</div><div class="line"><span class="bullet">- </span>列表项3</div></pre></td></tr></table></figure>

<ul>
<li>列表项1</li>
<li>列表项2</li>
<li>列表项3</li>
</ul>
<ul>
<li>列表项1</li>
<li>列表项2</li>
<li>列表项3</li>
</ul>
<p><br></p>
<h5 id="有序列表">有序列表</h5>
<p>下面是有序列表的示例</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>列表项1</div><div class="line"><span class="bullet">2. </span>列表项2</div><div class="line"><span class="bullet">3. </span>列表项3</div></pre></td></tr></table></figure>

<ol>
<li>列表项1</li>
<li>列表项2</li>
<li>列表项3</li>
</ol>
<p><br></p>
<h5 id="嵌套列表">嵌套列表</h5>
<p>下面是列表嵌套的示例</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>列表项1</div><div class="line"><span class="code">    * 项目1的子项</span></div><div class="line"><span class="code">    * 项目1的子项</span></div><div class="line"><span class="code">    * 项目1的子项</span></div><div class="line"><span class="bullet">2. </span>列表项2</div><div class="line"><span class="code">    * 项目2的子项</span></div><div class="line"><span class="code">    * 项目2的子项</span></div><div class="line"><span class="code">    * 项目2的子项</span></div><div class="line"><span class="bullet">3. </span>列表项3</div></pre></td></tr></table></figure>

<ol>
<li>列表项1<ul>
<li>项目1的子项</li>
<li>项目1的子项</li>
<li>项目1的子项</li>
</ul>
</li>
<li>列表项2<ul>
<li>项目2的子项</li>
<li>项目2的子项</li>
<li>项目2的子项</li>
</ul>
</li>
<li>列表项3</li>
</ol>
<h4 id="代码">代码</h4>
<p>在MD中，书写代码块也是非常便捷的，句法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">``` <span class="attr_selector">[language]</span> <span class="attr_selector">[title]</span> <span class="attr_selector">[url]</span> <span class="attr_selector">[link text]</span></div><div class="line"><span class="tag">code</span> <span class="tag">goes</span> <span class="tag">here</span></div><div class="line">```</div></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight"><pre>{% code [title] [lang:language] [url] [link text] %}<br>code goes here<br>{% endcode %}<br></pre></figure>


<p>一个JS代码的示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">`<span class="javascript"></span>``<span class="javascript">javascript _.compact https:<span class="comment">//lodash.com/docs  lodash.js</span></span></div><div class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</div><div class="line"><span class="comment">// → [1, 2, 3]</span></div><div class="line">``<span class="javascript"></span>`</div></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><figcaption><span>_.compact</span><a href="https://lodash.com/docs" target="_blank" rel="external">lodash.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">''</span>, <span class="number">3</span>]);</div><div class="line"><span class="comment">// → [1, 2, 3]</span></div></pre></td></tr></table></figure>

<h4 id="引用">引用</h4>
<p>引经据典是另一种增强说服力，彰显才识的方法。<br>MD中书写引用可以用如下简便的方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt; 原谅我这一生不鸡放纵爱自由</span></span></div><div class="line">&gt; 也会怕有一天会跌倒</div></pre></td></tr></table></figure>

<p>结果</p>
<blockquote>
<p>原谅我这一生不鸡放纵爱自由<br>也会怕有一天会跌倒</p>
</blockquote>
<p>也可以用以下方式书写更加健壮的引用，带出处，带连接。</p>
<figure class="highlight"><pre>{% blockquote @风一直在吹 <a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="external">https://twitter.com/devdocs/status/356095192085962752</a> %}<br>我这一生都在输，因为我不断战胜自己<br>{% endblockquote %}<br></pre></figure>


<p>结果</p>
<blockquote>

<p>我这一生都在输，因为我不断战胜自己</p>
<footer><strong>@风一直在吹</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="external">twitter.com/devdocs/status/&hellip;</a></cite></footer></blockquote>


<h4 id="Bootstrap_标签">Bootstrap 标签</h4>
<p>除了常规的MD句法，本主题内还可以书写一些Bootstrap句法，以此来让页面更加漂亮。<br>本主题基于<a href="https://github.com/wzpan/hexo-theme-freemind" target="_blank" rel="external">freemind</a>, 使用了其中的<a href="https://github.com/wzpan/hexo-tag-bootstrap" target="_blank" rel="external">hexo-tag-bootstrap</a>。</p>
<p>具体信息可以访问<a href="http://hahack.tk/hexo-theme-freemind/2014/03/16/tag-plugins-cn/" target="_blank" rel="external">这里</a>查看，下面是文字颜色的简单示例。</p>
<figure class="highlight"><pre>{% textcolor muted %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br>{% textcolor primary %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br>{% textcolor success %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br>{% textcolor info %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br>{% textcolor warning %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br>{% textcolor danger %}话说天下大势，分久必合，合久必分{% endtextcolor %}<br></pre></figure>


<p>结果：</p>
<p class="text-muted">话说天下大势，分久必合，合久必分</p><p class="text-primary">话说天下大势，分久必合，合久必分</p><p class="text-success">话说天下大势，分久必合，合久必分</p><p class="text-info">话说天下大势，分久必合，合久必分</p><p class="text-warning">话说天下大势，分久必合，合久必分</p><p class="text-danger">话说天下大势，分久必合，合久必分</p>

<h3 id="预览">预览</h3>
<p>书写过程中，你可能想要进行预览与效果查看，还记得之前我们已经将服务器在本地启动，直接刷新页面即可看到新增的文章入写入的改动。</p>
<p>但由于一些不为人知的原因，偶尔可能会出现更改未现效果，或者同名文章冗余的Bug。不要担心，<code>Ctrl+C</code> 停掉服务器，输入下面的命令清理一下缓存，再重新启动服务器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo clean <span class="comment">#删除之前生成的文件</span></div><div class="line">hexo s <span class="comment">#再次启动服务器进行预览</span></div></pre></td></tr></table></figure>

<h2 id="内容管理/_Content_Mgmt">内容管理/ Content Mgmt</h2>
<p>在书写文章过程中，我们需要的一些资源，比如附件，图片等，约定放在<code>source/asset/</code> 下面。</p>
<p>在此路径下新建一个与该文章名字一样的文件夹，里面存放该文章需要用到的全部资源。</p>
<p>而<code>asset</code>下面还有一个<code>common</code>文件夹，里面存放一些共用的资源，比如你写了一篇关于HTML5的文章，并且希望在首页显示一个HTML5 logo的缩略图，那么这个图片就应该存放在<code>common</code>里，因为另外的人以后可能也会分享相关文章，这时他就不必另取图片，而直接用<code>common</code>里的即可。</p>
<h2 id="提交更改/_Pull_request">提交更改/ Pull request</h2>
<p>完成了你的内容新增并且本地预览确认好效果后，我们来到提交步骤。</p>
<h3 id="提交更改">提交更改</h3>
<p>同时将改动后的项目源码提交到GitHub。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git status <span class="comment">#提交前最好查看一下文件变更</span></div><div class="line">git add --all</div><div class="line">git push origin master</div></pre></td></tr></table></figure>

<p>接下来，</p>
<p>将你的更改合并到源项目，也就是发起一个<code>pull request</code>。</p>
<p>在Github上你fork的项目页面，点击<code>pull request</code>：<br><img src="/jsbear/asset/posts/2014-10-22-hello-world/create_pr.jpg" alt="create pr step1"></p>
<p>来到创建页面：<br><img src="/jsbear/asset/posts/2014-10-22-hello-world/create_pr2.jpg" alt="create pr step2"></p>
<p>填写相关描述或者省略：<br><img src="/jsbear/asset/posts/2014-10-22-hello-world/create_pr3.jpg" alt="create pr step3"></p>
<p>之后便等待代码的<code>review</code>和合并吧！</p>
<p><br><br>即刻出发，享受书写来带的乐趣吧！</p>
<h1 id="附录/_Appendix">附录/ Appendix</h1>
<ul>
<li><a href="http://hexo.io/" target="_blank" rel="external">参见更多Hexo的信息</a></li>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">更加详尽的Markdown句法说明</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p class="text-success">Welcome, dude!</p>

<h2 id="初见/Intro">初见/Intro</h2>
<p><span class="dropcap">这</span>是使用<a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>搭建的静态站点，基于<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a>，内容采用<a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown</a> 撰写。</p>
<p>这里，我们进行知识分享扩散，文档整理存放，项目展示介绍。随着时间的推移，会沉淀更多的内容。</p>
<p>时间就像一坛尘封的酒酿，若干年后，就会发现它的醇香。</p>
<p>这里也是。</p>
]]>
    
    </summary>
    
      <category term="hexo" scheme="http://jsbear.baidu.com/tags/hexo/"/>
    
      <category term="markdown" scheme="http://jsbear.baidu.com/tags/markdown/"/>
    
      <category term="文档" scheme="http://jsbear.baidu.com/categories/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
